<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[core animation note]]></title>
      <url>http://lixuzong.com/2016/10/20/core_animation%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>我们所在屏幕上看到的都是Core Animation框架提供的，所以这并不是一个只关于动画的框架，他包含了我们在屏幕上所能看到的一切东西。这里首先说一下CALayer和UIView的关系，UIView是CALayer的管理者，CALayer是我们在屏幕上所能看到的UIView说呈现的。用过Photoshop的都知道，图片可以是很多图层的叠加计算的结果，与之类似，我们在屏幕上所看到的也是CALayer层叠加的结果，UIView就管理着这个相互叠加的过程。再者，UIView还管理着手势的响应。如果只从视图的角度来看的话，UIView只是对CALayer的一层封装。    </p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/core_animation.png" alt="core_animation_book"></p>
<a id="more"></a>
<p>首先先放上本书的<a href="https://www.gitbook.com/book/zsisme/ios-/details" target="_blank" rel="external">链接</a>，看的过程中有些翻译不是非常的准确，所以是结合着原版的一起看的。</p>
<h1 id="关于Layer的知识点"><a href="#关于Layer的知识点" class="headerlink" title="关于Layer的知识点"></a>关于Layer的知识点</h1><h2 id="图层树"><a href="#图层树" class="headerlink" title="图层树"></a>图层树</h2><p>关于图层树，我们看到的图层与UIView的层级是对应的，而UIView的层级与CALayer是对应的，其中CALayer tree又分为呈现树(presentation layer tree)和模型树(model layer tree)，因为layer默认是带有隐式动画的，但是我们直接改变layer属性的时候是立即生效的，也就是说layer的属性改变是立即执行的，但是界面上还是依然反应有一个动画的过程，所以这个时候就分成了两个tree，一个是界面上所呈现的层级（presentation layer tree），一个是我们修改的层级(model layer tree)。</p>
<h2 id="Layer的contents"><a href="#Layer的contents" class="headerlink" title="Layer的contents"></a>Layer的contents</h2><p>contents是一个id类型的对象，但是接收的类型应该是Core Foundation框架的类型，这里是因为在MAC OS系统上CGImage和NSImage类型值都是可以起作用的。在iOS上的话就是用bridge将CGImage转成Core Foundation的id类型就可以了。下面具体看一下contens的属性。</p>
<h3 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h3><ul>
<li><p>contentsGravity<br>我们操作UIView属性的时候，会有一个contentMode属性定义怎么与图层的边界对其，与之对应的CALayer属性就是contentsGravity属性，并且其根本上操作的还是对应的Layer的属性。</p>
</li>
<li><p>contentsScale<br>iOS的屏幕的单位并不是直接使用像素，而是直接使用点来作为距离单位，这样的话方便兼容不同分辨率的屏幕。scale就是一个点包含几个像素，视网膜屏就是2.</p>
</li>
<li><p>maskToBounds<br>默认情况下，UIView会绘制超过边界的内容或者子视图，CALayer下也是这样的。UIView有一个叫做clipsToBounds的属性可以用来决定是否显示超出边界的内容，CALayer对应的属性叫做maskToBounds。</p>
</li>
<li><p>contentsRect<br>这个属性是用来给图片截图的，配合maskToBoundds可以确定显现image的局部信息。</p>
</li>
<li><p>contentsCenter<br>是用来确定contents变大情况下的拉伸情况。</p>
</li>
</ul>
<h3 id="custom-drawing"><a href="#custom-drawing" class="headerlink" title="custom drawing"></a>custom drawing</h3><p>是在不设置contents属性为image的情况下直接画一个，在UIView里面有<em>drawRect:</em>，虽然<em>drawRect</em>是UIView的方法，但是在底层还是通过CALayer安排重绘工作和保存产生的图片的。绘制用到的是CADelegate提供的两个方法，分别是<em>drawLayer:(CALayer)layer inContext:(CGContext)ctx</em>调用这个方法之前CALayer会自动生成一个空的图像（由bounds和contentsSacle决定）和一个Core Graphics的绘制上下文环境，为绘制图做准备。调用的时候与UIView方法<em>setNeedDisplay</em>类似，CALayer的方法是调用<em>displayLayer</em>来触发重绘操作。</p>
<h2 id="图层几何"><a href="#图层几何" class="headerlink" title="图层几何"></a>图层几何</h2><p>图层几何是看图层内部是如何根据父图层和兄弟图层来控制位置和尺寸的。另外我们也会涉及如何管理图层的几何结构，以及它是如何被自动调整和自动布局影响的。</p>
<ul>
<li><p>布局<br>UIView有三个比较重要的布局属性：frame\bounds\center，CALayer对应的叫做frame\bounds\position，其中center和position是相对于父图层anchorPoint（锚点）所在的位置。frame的值和bounds并不是严格的宽高对应的，当一个视图发生旋转之后，其bounds是不便的，而frame的值是包含bounds的矩形。这里就可以看出frame是一个虚拟属性，是根据bounds、position和transform计算出来的，所以改变其中一个值都会使frame发生改变。</p>
</li>
<li><p>锚点<br>contentsRect和contentsCenter属性类似，anchorPoint用单位坐标来描述，也就是图层的相对坐标，图层左上角是{0, 0}，右下角是{1, 1}，因此默认坐标是{0.5, 0.5}。anchorPoint可以通过指定x和y值小于0或者大于1，使它放置在图层范围之外。改变锚点也会影响到frame的值。</p>
</li>
<li><p>坐标系<br>和视图一样，图层在图层树当中也是相对于父图层按层级关系放置，一个图层的position依赖于它父图层的bounds，如果父图层发生了移动，它的所有子图层也会跟着移动。与UIView相似，也有改变坐标系的方法。与UIView不同的是CALayer是三维空间的构图，可以改变zPosition和anchorPointZ来改变z轴上的顺序。比如layer重叠顺序。</p>
</li>
<li><p>Hit Testing<br>CALayer并不关心任何响应链事件，所以不能直接处理触摸事件或者手势。但是它有一系列的方法帮你处理事件：<em>-containsPoint:</em>和<em>-hitTest:</em>。第一个方法可以判定点击的点是否在这个layer的区域内，但是要注意的是坐标系的转换，第二个方式是直接判断响应这个点的图层，所以没必要转换坐标系，结果是返回这个响应的图层。</p>
</li>
<li><p>layout<br>与UIView的另一个不同点，layer是没有autoLayout的属性的，所以这也是要使用UIView而不是使用CALayer的原因之一。如果想控制layer的布局，这里提供了一个CALayerDelegate的方法.</p>
</li>
</ul>
<blockquote>
<p>-(void)layoutSublayersOfLayer:(CALayer*)layer</p>
</blockquote>
<p>当图层的bounds改变或者图层 <em>-setNeedsLayout</em> 方法被调用的时候，这个函数就会执行。在这个方法里面可以重新摆放或者调整子图层的大小。</p>
<h2 id="Layer视觉效果"><a href="#Layer视觉效果" class="headerlink" title="Layer视觉效果"></a>Layer视觉效果</h2><ul>
<li><p>圆角<br>圆角主要是使用cornerRadius属性，直接设置半径就会出现圆角的效果。同时设置圆角会触发离屏渲染。</p>
</li>
<li><p>图层边框<br>绘制边框使用的是borderColor和borderWidth属性，其中borderColor是CGColorRef类型的，所以不是Cocoa框架的对象，即便CGColorRef是强引用也只能声明称assign。</p>
</li>
<li><p>阴影<br>  给shadowOpacity属性一个大于默认值（也就是0）的值，阴影就可以显示在任意图层之下。shadowOpacity是一个必须在0.0（不可见）和1.0（完全不透明）之间的浮点数。如果设置为1.0，将会显示一个有轻微模糊的黑色阴影稍微在图层之上。若要改动阴影的表现，你可以使用CALayer的另外三个属性：shadowColor，shadowOffset和shadowRadius。另外阴影也会有性能隐患。</p>
</li>
<li><p>蒙版<br>蒙版的作用就是覆盖一层Layer，将这个layer的轮廓显示出来，填充内容是contents的内容。</p>
</li>
<li><p>拉伸过滤<br>最后就是minificationFilter（缩小）和magnificationFilter（放大）属性。这两个属性主要是使用在要展示非图像原始大小情况下使用，遵循怎样的算法进行拉伸和缩放。</p>
</li>
<li><p>组透明<br>当我们给一个layer tree添加透明度属性的时候，往往是里面的layer的透明度会小一些，因为里面的layer是父layer与其透明度的一个混合，所以会出现两个layer混合之后的效果不是我们想要的效果，这个时候就需要组透明来解决。这里有两种解决方案，一种是将layer光栅化成一个图层，这样的话透明度就一致了，另一个方法就是通过设置Info.plist文件中的UIViewGroupOpacity为YES来达到这个效果，但是会对整个App造成影响。</p>
</li>
</ul>
<h2 id="CGAffineTransform"><a href="#CGAffineTransform" class="headerlink" title="CGAffineTransform"></a>CGAffineTransform</h2><p>首先，所有的变换都是基于CGPoint的，仿射变换之后的矩形两对边是相互平行的。</p>
<h2 id="CGTransform3D"><a href="#CGTransform3D" class="headerlink" title="CGTransform3D"></a>CGTransform3D</h2><p>3D变换主要是配置一个矩阵来实现每个点的变化，从而达到整个layer实现3D变换的效果。要想做到灭点相同的话，必须要将layer都放在view的中心，然后在平移到指定的位置，改变layer的frame的话灭点也会发生改变。还有一个简单的办法就是使用sublayerTransform属性。我们可以任意的放置子layer的位置，这样的话也会共享一个灭点。</p>
<h2 id="专用图层"><a href="#专用图层" class="headerlink" title="专用图层"></a>专用图层</h2><h3 id="CAShapeLayer"><a href="#CAShapeLayer" class="headerlink" title="CAShapeLayer"></a>CAShapeLayer</h3><p><code>CAShapeLayer</code>是一个通过矢量图而不是通过bitmap来绘制的图层子类。指定线宽和颜色等属性，用CGPath来定义想要绘制的图形，最后CAShapeLayer就会自动的渲染出来。与直接向CALayer绘制路径相比，CAShapeLayer的优点如下：</p>
<blockquote>
<p>1、渲染快速。<code>CAShapeLayer</code>使用了硬件加速，绘制同一图形会比用Core Graphics快很多。<br>2、高效使用内存。一个<code>CAShapeLayer</code>不需要像普通layer一样创建一个contents图形，所以无论多大都不会占用过多的内存。<br>3、不会被图层边界裁掉。一个<code>CAShapeLayer</code>可以在边界之外绘制,不会像普通的layer被裁减掉。<br>4、不会出现像素化。当你给CAShapeLayer做3D变换的时候，他不像一个contents普通图层一样变得像素化。</p>
</blockquote>
<p>使用CAShapeLayer主要就是设置path属性，path是CGPathRef类型，但是为了方便管理内存，使用UIKit框架的UIBezierPath来创建，然后转成CGPathRef类型赋值给path属性，这样的话就会渲染出一个path形状的图层。利用之前的蒙版的功能，我们可以直接将contents裁剪成任意形状。例如可以让两个角圆角，另外两个角是正常的，这些都是很容易实现的。</p>
<h3 id="CATextLayer"><a href="#CATextLayer" class="headerlink" title="CATextLayer"></a>CATextLayer</h3><p>它以图层的形式包含了UILabel几乎所有的绘制特性，另外还提供了一些新的额外的特性。在ios6之前UILabel是用WebKit来实现的，而CATextLayer是用Core Text支持的，所以渲染速度要快很多，但是iOS7之后文字渲染交给了Text Kit来实现，其底层还是使用Core Text，所以性能上的差距应该没有这么明显了（自己认为的）。CATextLayer可以使用普通文本和富文本。</p>
<h3 id="CATransformLayer"><a href="#CATransformLayer" class="headerlink" title="CATransformLayer"></a>CATransformLayer</h3><p>这个属性没有自己的contents属性，而是管理子layer的Transform变化，主要是为了解决CALayer会将其子layer平面化，而CATransformLayer不会平面化其子layer。这样的话就可以在一个layer里面构造两种不同视角的3D物体。</p>
<h3 id="CAGradientLayer"><a href="#CAGradientLayer" class="headerlink" title="CAGradientLayer"></a>CAGradientLayer</h3><p>CAGradientLayer是用来生成两种或更多颜色平滑渐变的。用Core Graphics复制一个CAGradientLayer并将内容绘制到一个普通图层的寄宿图也是有可能的，但是CAGradientLayer的真正好处在于绘制使用了硬件加速。</p>
<h3 id="CAReplicatorLayer"><a href="#CAReplicatorLayer" class="headerlink" title="CAReplicatorLayer"></a>CAReplicatorLayer</h3><p>其目的是高效生成许多相似的图层。它会绘制一个或多个图层的子图层，并且在每个复制体上应用不同的变换。使用的时候就是将layer加入到CARelicatorLayer类型的layer中，然后可以在CARelicatorLayer中设置复制的数量和变换。可以高效的来做反射的效果。</p>
<h3 id="CAScrollLayer"><a href="#CAScrollLayer" class="headerlink" title="CAScrollLayer"></a>CAScrollLayer</h3><p>Core Animation并不处理用户输入，所以CAScrollLayer并不负责将触摸事件转换为滑动事件，既不渲染滚动条，也不实现任何iOS指定行为例如滑动反弹。用法就是直接重写<code>+ (Class)layerClass</code>方法，将UIView的根layer返回成CAScrollLayer类型，这样的话其中的子layer都是可以滑动的。</p>
<h3 id="CATiledLayer"><a href="#CATiledLayer" class="headerlink" title="CATiledLayer"></a>CATiledLayer</h3><p>有些时候你可能需要绘制一个很大的图片，常见的例子就是一个高像素的照片或者是地球表面的详细地图。iOS应用通畅运行在内存受限的设备上，所以读取整个图片到内存中是不明智的。载入大图可能会相当地慢，那些对你看上去比较方便的做法（在主线程调用UIImage的-imageNamed:方法或者-imageWithContentsOfFile:方法）将会阻塞你的用户界面，至少会引起动画卡顿现象。<br>能高效绘制在iOS上的图片也有一个大小限制。所有显示在屏幕上的图片最终都会被转化为OpenGL纹理，同时OpenGL有一个最大的纹理尺寸（通常是2048/2048，或4096/4096，这个取决于设备型号）。如果你想在单个纹理中显示一个比这大的图，即便图片已经存在于内存中了，你仍然会遇到很大的性能问题，因为Core Animation强制用CPU处理图片而不是更快的GPU（见第12章『速度的曲调』，和第13章『高效绘图』，它更加详细地解释了软件绘制和硬件绘制）。<br>CATiledLayer为载入大图造成的性能问题提供了一个解决方案：将大图分解成小片然后将他们单独按需载入.</p>
<h3 id="CAEmitterLayer"><a href="#CAEmitterLayer" class="headerlink" title="CAEmitterLayer"></a>CAEmitterLayer</h3><p>是一个高性能的粒子引擎，被用来创建实时例子动画如：烟雾，火，雨等等这些效果。</p>
<h3 id="CAEAGLLayer"><a href="#CAEAGLLayer" class="headerlink" title="CAEAGLLayer"></a>CAEAGLLayer</h3><p>它是CALayer的一个子类，用来显示任意的OpenGL图形。</p>
<h3 id="AVPlayerLayer"><a href="#AVPlayerLayer" class="headerlink" title="AVPlayerLayer"></a>AVPlayerLayer</h3><p>AVPlayerLayer是有别的框架（AVFoundation）提供的，它和Core Animation紧密地结合在一起，提供了一个CALayer子类来显示自定义的内容类型。AVPlayerLayer是用来在iOS上播放视频的。他是高级接口例如MPMoivePlayer的底层实现，提供了显示视频的底层控制。AVPlayerLayer的使用相当简单：你可以用+playerLayerWithPlayer:方法创建一个已经绑定了视频播放器的图层，或者你可以先创建一个图层，然后用player属性绑定一个AVPlayer实例。</p>
<h1 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h1><h2 id="implicit-animation"><a href="#implicit-animation" class="headerlink" title="implicit animation"></a>implicit animation</h2><p>隐式动画就是系统会自动的给layer做动画，layer位置、颜色等的改变会引起一个0.25秒的动画过程。core animation是根据什么来判断动画类型和时间的那，看起来是自动的设置，实际上是有事务来进行管理的。</p>
<blockquote>
<p>事务实际上是Core Animation用来包含一系列属性动画集合的机制，任何用指定事务去改变可以做动画的图层属性都不会立刻发生变化，而是当事务一旦提交的时候开始用一个动画过渡到新值。事务是通过CATransaction类来做管理，这个类的设计有些奇怪，不像你从它的命名预期的那样去管理一个简单的事务，而是管理了一叠你不能访问的事务。CATransaction没有属性或者实例方法，并且也不能用+alloc和-init方法创建它。但是可以用+begin和+commit分别来入栈或者出栈。即使不显示的调用begin方法，在一次runloop循环中</p>
</blockquote>
<p>我们也可以手动的关闭动画，layer tree中，作为UIView的根layer的动画是被关上的，并不是通过layer的开关关闭的，首先看一下CALayer的代理方法。</p>
<ul>
<li>图层首先检测它是否有委托，并且是否实现CALayerDelegate协议指定的-actionForLayer:forKey方法。如果有，直接调用并返回结果。</li>
<li>如果没有委托，或者委托没有实现-actionForLayer:forKey方法，图层接着检查包含属性名称对应行为映射的actions字典。</li>
<li>如果actions字典没有包含对应的属性，那么图层接着在它的style字典接着搜索属性名。</li>
<li>最后，如果在style里面也找不到对应的行为，那么图层将会直接调用定义了每个属性的标准行为的-defaultActionForKey:方法。</li>
</ul>
<p>于是这就解释了UIKit是如何禁用隐式动画的：每个UIView对它关联的图层都扮演了一个委托，并且提供了-actionForLayer:forKey的实现方法。对于改变可动画的属性，当其不在一个动画块的实现中，UIView对所有图层行为返回nil，但是在动画block范围之内，它就返回了一个非空值。</p>
<h2 id="explicit-aniamtion"><a href="#explicit-aniamtion" class="headerlink" title="explicit aniamtion"></a>explicit aniamtion</h2><p>显示动画是使用CAAnimation做的动画，我们来看一下CAAniamtion的子类。</p>
<h3 id="CAPropertyAniamtion（属性动画）"><a href="#CAPropertyAniamtion（属性动画）" class="headerlink" title="CAPropertyAniamtion（属性动画）"></a>CAPropertyAniamtion（属性动画）</h3><ul>
<li><p>CABasicAniamtion<br>CABasicAnimation是设置Layer的属性的fromValue和toValue，然后有一个渐变的过程，这个其实是和隐式动画相似，只是多了一个设置fromValue。</p>
</li>
<li><p>CAKeyframeAnimation<br>CAKeyframeAnimation是另一种UIKit没有暴露出来但是功能强大的类，与CABasicAniamtion相似，也是ACPropertyAniamtion的子类，也是只能作用于一个属性，但是和basic不同的是，它不限制于设置一个起始和最终值，而是可以根据一系列任意的值来做动画。一种方式是根据values数组来给出关键帧，core animation会在这些关键帧之间自动的插入动画，但是这种方式并不直观，还有一种方式就是使用CGPath，这是一种直观的方式，使用CoreGraphics函数定义运动序列来绘制动画。</p>
</li>
<li><p>虚拟属性做动画<br>虚拟属性指的是layer没用暴露的属性，比如rotation，transfrom等，我们可以指定 <em>keyPath = @“transform.rotation”</em> 来对角度做动画。</p>
</li>
<li><p>动画组（CAAnimationGroup）<br>可以将动画放到CAAnimationGroup里面，将不同的动画组合进行</p>
</li>
</ul>
<h3 id="过渡动画（CATransition）"><a href="#过渡动画（CATransition）" class="headerlink" title="过渡动画（CATransition）"></a>过渡动画（CATransition）</h3><p>对于没有办法做动画的属性，或者交换一段文本和图片，或者用一段网格来替换，这个时候属性动画是没用作用的。属性动画只对图层可动画属性起作用，所以如果要改变一个不能动画的属性（比如图片，因为CoreAnimation不知道什么时候插入图片），又或者成层级关系中添加或者移除图层，属性动画将不起作用，于是就有了过度的概念。    </p>
<blockquote>
<p>过度并不像属性动画那样平滑的在两个值之间做动画，而是影响到整个图层的变化。过度动画首先展示之前的图层外观，然后通过一个过度变换到新的外观。</p>
</blockquote>
<p>我们使用CATransition来管理过度效果，和别的子类不同，CATransition有一个type和subType来标识变换效果。type是一个NSString类型，提供了四种过度类型，分别是：</p>
<blockquote>
<p>kCATransitionFade<br>kCATransitionMoveIn<br>kCATransitionPush<br>kCATransitionReveal   </p>
</blockquote>
<p>过渡动画和之前的属性动画或者动画组添加到图层上的方式一致，都是通过-addAnimation:forKey:方法。但是和属性动画不同的是，对指定的图层一次只能使用一次CATransition，因此，无论你对动画的键设置什么值，过渡动画都会对它的键设置成“transition”，也就是常量kCATransition。</p>
<blockquote>
<p>CATransision可以对图层任何变化平滑过渡的事实使得它成为那些不好做动画的属性图层行为的理想候选。苹果当然意识到了这点，并且当设置了CALayer的content属性的时候，CATransition的确是默认的行为。但是对于视图关联的图层，或者是其他隐式动画的行为，这个特性依然是被禁用的，但是对于你自己创建的图层，这意味着对图层contents图片做的改动都会自动附上淡入淡出的动画。</p>
</blockquote>
<h4 id="图层树的动画"><a href="#图层树的动画" class="headerlink" title="图层树的动画"></a>图层树的动画</h4><p>CATransition并不作用于指定的图层属性，这就是说你可以在即使不能准确得知改变了什么的情况下对图层做动画，例如，在不知道UITableView哪一行被添加或者删除的情况下，直接就可以平滑地刷新它，或者在不知道UIViewController内部的视图层级的情况下对两个不同的实例做过渡动画。因为它们不仅涉及到图层的属性，而且是整个图层树的改变–我们在这种动画的过程中手动在层级关系中添加或者移除图层。要确保CATransition添加到的图层在过渡动画发生时不会在树状结构中被移除，否则CATransition将会和图层一起被移除。一般来说，你只需要将动画添加到被影响图层的superlayer。</p>
<h4 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h4><p>苹果通过UIView +transitionFromView:toView:duration:options:completion:和+transitionWithView:duration:options:animations:方法提供了Core Animation的过渡特性。但是这里的可用的过渡选项和CATransition的type属性提供的常量完全不同</p>
<h1 id="动画的时间、缓冲"><a href="#动画的时间、缓冲" class="headerlink" title="动画的时间、缓冲"></a>动画的时间、缓冲</h1><h2 id="model-layer-amp-presentation-layer"><a href="#model-layer-amp-presentation-layer" class="headerlink" title="model layer &amp; presentation layer"></a>model layer &amp; presentation layer</h2><p>我们直接改变layer的position，可以发现position属性会直接发生变化，但是屏幕上我们看到的layer却是有一个渐变的动画，而不是根据我们设置的属性实时的发生变化，所以，详细的划分一下，这里的layer就是model layer，其属性表示的是动画结束之后layer的属性，而屏幕上我们直接看到的就是presentation layer，layer实时在屏幕上的位置。</p>
<h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h2 id="性能陷阱"><a href="#性能陷阱" class="headerlink" title="性能陷阱"></a>性能陷阱</h2><p>软件绘图不仅效率低，还会消耗可观的内存。CALayer只需要一些与自己相关的内存：只有它的寄宿图会消耗一定的内存空间。即使直接赋给contents属性一张图片，也不需要增加额外的照片存储大小。如果相同的一张图片被多个图层作为contents属性，那么他们将会共用同一块内存，而不是复制内存块。</p>
<p>但是一旦你实现了CALayerDelegate协议中的-drawLayer:inContext:方法或者UIView中的-drawRect:方法（其实就是前者的包装方法），图层就创建了一个绘制上下文，这个上下文需要的大小的内存可从这个算式得出：图层宽<em>图层高</em>4字节，宽高的单位均为像素。对于一个在Retina iPad上的全屏图层来说，这个内存量就是 2048<em>1526</em>4字节，相当于12MB内存，图层每次重绘的时候都需要重新抹掉内存然后重新分配。</p>
<h2 id="加载图片消耗内存和占用CPU的原因"><a href="#加载图片消耗内存和占用CPU的原因" class="headerlink" title="加载图片消耗内存和占用CPU的原因"></a>加载图片消耗内存和占用CPU的原因</h2><p> 一旦图片文件被加载就必须要进行解码，解码过程是一个相当复杂的任务，需要消耗非常长的时间。解码后的图片将同样使用相当大的内存。    </p>
<p>  用于加载的CPU时间相对于解码来说根据图片格式而不同。对于PNG图片来说，加载会比JPEG更长，因为文件可能更大，但是解码会相对较快，而且Xcode会把PNG图片进行解码优化之后引入工程。JPEG图片更小，加载更快，但是解压的步骤要消耗更长的时间，因为JPEG解压算法比基于zip的PNG算法更加复杂。</p>
<h2 id="图片加载的性能优化（TableView优化）"><a href="#图片加载的性能优化（TableView优化）" class="headerlink" title="图片加载的性能优化（TableView优化）"></a>图片加载的性能优化（TableView优化）</h2><ul>
<li>在后台线程中加载图片，会有效果，但是并不是性能的瓶颈。</li>
<li>iOS为了节省内存延迟解压,解压会消耗很长的时间，这里带来的问题就是在使用的时候进行解压，就会造成界面的卡顿<em>[UIImage imageWithContentsOfFile:]</em>会延迟图片的解压，<em>[UIimage imageName:]</em>会立即解压图片，另外两种方式也会直接解压图片，一种是作为<em>layer</em>的<em>contents</em>属性的时候，还有一种就是作为<em>UIImageView</em>的<em>image</em>属性的时候，但是这两种方法必须在主线程中才有效。第四种方式是不用UIKit框架，直接使用ImageIO框架来实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSInteger index = indexPath.row;NSURL *imageURL = [NSURL fileURLWithPath:self.imagePaths[index]]; </span><br><span class="line">NSDictionary *options = @&#123;(__bridge id)kCGImageSourceShouldCache: @YES&#125;;</span><br><span class="line">CGImageSourceRef source = CGImageSourceCreateWithURL((__bridge CFURLRef)imageURL, NULL);CGImageRef imageRef = CGImageSourceCreateImageAtIndex(source, 0,(__bridge CFDictionaryRef)options);UIImage *image = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef);CFRelease(source);</span><br></pre></td></tr></table></figure>
<p>这里还有第五种方式依然使用UIKit框架来实现立即解压图片，以为绘制图片之前会解压图片，那么就直接将图片画到CGContext里面，从而实现立即解压，这有个好处就是不是必须在主线程中实现</p>
<ul>
<li>中间插一个离屏渲染导致的性能问题，前面有说过设置Layer的conerRadius属性会触发离屏渲染，导致内存增加。另外maskToBounds属性是结合conerRadius使用的，所以这个属性也是需要注意的。</li>
</ul>
<blockquote>
<p> 离屏渲染影响性能的原因：「直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。因为这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。」触发离屏渲染后这种转换发生在每一帧，在界面的滚动过程中如果有大量的离屏渲染发生时会严重影响帧率。</p>
</blockquote>
<p>文／seedante（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/ca51c9d3575b" target="_blank" rel="external">http://www.jianshu.com/p/ca51c9d3575b</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
<ul>
<li>缓存图片也是可以实现优化，<em>[UIImage imageNamed:]</em>方法会直接缓存之后的图片，但是我们并不能手动控制，而且也不知道什么时候图片是被缓存的，那么就要使用<em>NSCache</em>来实现缓存，并且缓存的是解压之后的图片，使用UIKit的话就是要在<em>CGContext</em>里面实现。这里是处理好的例子：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">@interface ViewController() </span><br><span class="line"></span><br><span class="line">@property (nonatomic, copy) NSArray *imagePaths;</span><br><span class="line">@property (nonatomic, weak) IBOutlet UICollectionView *collectionView;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">    //set up data</span><br><span class="line">    self.imagePaths = [[NSBundle mainBundle] pathsForResourcesOfType:@&quot;png&quot; ￼inDirectory:@&quot;Vacation Photos&quot;];</span><br><span class="line">    //register cell class</span><br><span class="line">    [self.collectionView registerClass:[UICollectionViewCell class] forCellWithReuseIdentifier:@&quot;Cell&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSInteger)collectionView:(UICollectionView *)collectionView numberOfItemsInSection:(NSInteger)section</span><br><span class="line">&#123;</span><br><span class="line">    return [self.imagePaths count];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UIImage *)loadImageAtIndex:(NSUInteger)index</span><br><span class="line">&#123;</span><br><span class="line">    //set up cache</span><br><span class="line">    static NSCache *cache = nil;</span><br><span class="line">    if (!cache) &#123;</span><br><span class="line">        cache = [[NSCache alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    //if already cached, return immediately</span><br><span class="line">    UIImage *image = [cache objectForKey:@(index)];</span><br><span class="line">    if (image) &#123;</span><br><span class="line">        return [image isKindOfClass:[NSNull class]]? nil: image;</span><br><span class="line">    &#125;</span><br><span class="line">    //set placeholder to avoid reloading image multiple times</span><br><span class="line">    [cache setObject:[NSNull null] forKey:@(index)];</span><br><span class="line">    //switch to background thread</span><br><span class="line">    dispatch_async( dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW, 0), ^&#123;</span><br><span class="line">        //load image</span><br><span class="line">        NSString *imagePath = self.imagePaths[index];</span><br><span class="line">        UIImage *image = [UIImage imageWithContentsOfFile:imagePath];</span><br><span class="line">        //redraw image using device context</span><br><span class="line">        UIGraphicsBeginImageContextWithOptions(image.size, YES, 0);</span><br><span class="line">        [image drawAtPoint:CGPointZero];</span><br><span class="line">        image = UIGraphicsGetImageFromCurrentImageContext();</span><br><span class="line">        UIGraphicsEndImageContext();</span><br><span class="line">        //set image for correct image view</span><br><span class="line">        dispatch_async(dispatch_get_main_queue(), ^&#123; //cache the image</span><br><span class="line">            [cache setObject:image forKey:@(index)];</span><br><span class="line">            //display the image</span><br><span class="line">            NSIndexPath *indexPath = [NSIndexPath indexPathForItem: index inSection:0]; UICollectionViewCell *cell = [self.collectionView cellForItemAtIndexPath:indexPath];</span><br><span class="line">            UIImageView *imageView = [cell.contentView.subviews lastObject];</span><br><span class="line">            imageView.image = image;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    //not loaded yet</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">    //dequeue cell</span><br><span class="line">    UICollectionViewCell *cell = [collectionView dequeueReusableCellWithReuseIdentifier:@&quot;Cell&quot; forIndexPath:indexPath];</span><br><span class="line">    //add image view</span><br><span class="line">    UIImageView *imageView = [cell.contentView.subviews lastObject];</span><br><span class="line">    if (!imageView) &#123;</span><br><span class="line">        imageView = [[UIImageView alloc] initWithFrame:cell.contentView.bounds];</span><br><span class="line">        imageView.contentMode = UIViewContentModeScaleAspectFit;</span><br><span class="line">        [cell.contentView addSubview:imageView];</span><br><span class="line">    &#125;</span><br><span class="line">    //set or load image for this index</span><br><span class="line">    imageView.image = [self loadImageAtIndex:indexPath.item];</span><br><span class="line">    //preload image for previous and next index</span><br><span class="line">    if (indexPath.item &lt; [self.imagePaths count] - 1) &#123;</span><br><span class="line">        [self loadImageAtIndex:indexPath.item + 1]; &#125;</span><br><span class="line">    if (indexPath.item &gt; 0) &#123;</span><br><span class="line">        [self loadImageAtIndex:indexPath.item - 1]; &#125;</span><br><span class="line">    return cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ios中的设计模式实现]]></title>
      <url>http://lixuzong.com/2016/08/15/ios%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>大部分的Demo可以在这里查看：<a href="https://github.com/lixuzong/iosPatternDemo" target="_blank" rel="external">Demo在这里</a></p>
<p>首先先讲一下大概的设计模式的分类。</p>
<ul>
<li>1、对象创建，主要是生成对象的方法。</li>
<li>2、接口适配，为了解决两个类之间接口不吻合</li>
<li>3、对象去耦，对象去耦合有利于代码的复用</li>
<li>4、抽象集合，将要用的组合抽离出来，主要有组合模式</li>
<li>5、行为扩展，在已有功能的基础上扩展功能</li>
<li>6、算法封装</li>
</ul>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E4%B9%A6.png" alt="设计模式"></p>
<a id="more"></a>
<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><ul>
<li>原型</li>
<li>工厂方法</li>
<li>抽象工厂</li>
<li>生成器</li>
<li>单例</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>工厂方法模式： 定义创建对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到其子类。</p>
</blockquote>
<p>首先先看一下类图：<br><img src="http://o835bn5qj.bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="工厂方法"></p>
<p>通过类图可以很清楚的看到，有一个product对象需要被创建，创建对象的方法来自于继承子类重写Creator，也就是说需要知道子类的具体类型才能够进行创建。</p>
<p>在<a href="http://item.jd.com/11402853.html" target="_blank" rel="external">《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》</a>中也有提及到的虚拟工厂方法，在iOS里面叫做类族，比较典型的类就是我们经常使用的NSArray类，通常我们会认为NSArray是一个类，提供了一些方法，但是在NSArray类里面获得确实其子类的实例，这就是一个典型的工厂模式。</p>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>编译时无法准确预期要创建的对象的类。</li>
<li>类想让其子类决定在运行时创建什么。</li>
<li>类若有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。</li>
</ul>
<h2 id="抽象工程模式"><a href="#抽象工程模式" class="headerlink" title="抽象工程模式"></a>抽象工程模式</h2><blockquote>
<p>提供一个创建一系列相关或者相互依赖的接口的对象，而无需指定他们具体的类。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png" alt="抽象工厂"></p>
<p>通过类图我们可以看出，client通过抽象工厂来创建ProductA和ProductB，但是client只要通过AbstractFactory就可以直接获得其子类，而不需要知道子类。这就是为什么是抽象工厂，在工厂方法的基础上隐藏了其实现的具体子类，在工厂方法的基础上又进行了一次抽象。</p>
<p>说到抽象工厂模式的话，就是要与工厂方法比较一下。</p>
<table>
<thead>
<tr>
<th>抽象工厂</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过对象组合创建抽象产品</td>
<td>通过类继承创建抽象产品</td>
</tr>
<tr>
<td>创建多系列产品</td>
<td>创建一种产品</td>
</tr>
<tr>
<td>必须修改父类的接口才能支持新的产品</td>
<td>子类化创建者并重载工厂方法以创建新的产品</td>
</tr>
</tbody>
</table>
<p>假设你现在正在看Demo的话，这里可以简单的说一下。其实抽象工厂就是在工厂方法的基础上将具体的类型也隐藏起来。所以工厂方法里需要知道之类的类型才能够创建对象，而抽象工厂不需要知道具体的子类的类型就可以直接通过父类的方法创建子类对象，所以是在工厂方法的基础上又抽象了一层。</p>
<h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><blockquote>
<p>生成器模式：将一个复杂对象的构建与他的表现分离，使得同样的构建过程可以创建不同的表现。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E7%94%9F%E6%88%90%E5%99%A8.png" alt="生成器模式"></p>
<p>通过类图我们可以看出来，Director与一个builder对象相识，是通过这个Builder对象来获取对象的。</p>
<p>根据我的理解，就是单独使用一个类来管理生成对象，client并不需要自己创建对象，只需要告诉生成器我需要什么样的对象，这样生成器就会根据需求创建响应的对象。这样的话就会将构建与表现分离了。<a href="https://github.com/lixuzong/BuilderPattern" target="_blank" rel="external">Demo在这里</a></p>
<h3 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>需要创建设计各种部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见例子是构建组合对象。</li>
<li>构建过程需要以不同的方式（例如，部件或表现的不同组合）构建对象。</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>单例模式： 保证一个类只有一个实例，并提供一个访问他的全局访问点。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E5%8D%95%E4%BE%8B.png" alt="单例模式"></p>
<p>单例模式是iOS里面比较常用的设计模式。一般我们平时要求不是很严格的时候是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)shareCharacter &#123;</span><br><span class="line">    static Character *character;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        character = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return character;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <em>dispatch_once</em> 是为了线程安全，这个也可以用加锁来解决，但一般是交给GCD来实现，会做部分的优化。为什么会说是不严格的单例的，主要是以下两个方面：</p>
<ul>
<li>发起调用的对象不能以其他分配方式实例化单例对象。否则，有可能创建单例的多个实例。</li>
<li>对单例对象实例化的限制应该与引用计数内存模型共存。</li>
</ul>
<p>因为ARC目前已经完全取代了MRC所以第二点也就没有必要考虑了，但是仍然需要考虑创建对象的唯一性。也看到有一种方式直接在其他创建对象的方法中强制抛出异常，个人认为是不可取的。一言不合就贴代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static Character *character;</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareCharacter &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        character = [[super allocWithZone:NULL] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return character;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return [self shareCharacter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)copy &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如要是对内存做了限制，首先说一下生成对象的两种方式 <em>[Character shareCharacter]</em> 和 <em>[[Character alloc] init]</em> 需要让两种方法都返回的是同一块内存地址，因为objective-c采用的是两段式的初始化方法，所有只要控制 <em>+ (instancetype)allocWithZone:(struct _NSZone </em>)zone* 返回同样的内存地址就可以了。</p>
<blockquote>
<p>这里碰到了一个疑惑就是在网上看到 <em>- (instancetype)copy {return self;}</em> 的另一个版本是 <em>- (instancetype)copy {return character;}</em> 就有点困惑self的指代问题，通过 <em>[self shareCharacter]</em> 可以看出self指代的是当前的类，怎么在返回的时候是一个对象那？后来查了下资料并结合ios runtime的特性，原来self是在运行的时候动态决定其指代的，可以是当前类，也可以是当前的对象。那么这里的理解就是在类方法里面就是当前类，在实例方法里面就是当前对象。</p>
</blockquote>
<h1 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h1><ul>
<li>适配器</li>
<li>桥接</li>
<li>外观</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作</p>
</blockquote>
<p>适配器模式在ios里面的实现分为两种，分别是类适配器和对象适配器。假设我们有A类，B类，把A类当成客户，但是A类不能直接调用B类的接口，所以需要一个适配器C类。</p>
<ul>
<li>类适配器：将适配器C类继承于B类，对A暴露相关功能的接口。</li>
</ul>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8.png" alt="类适配器"></p>
<ul>
<li>对象适配器：适配器C类拥有B类的实例，对A暴露相关功能的接口。</li>
</ul>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8.png" alt="对象适配器"></p>
<blockquote>
<p>在使用的过程中不使用适配器模式也能实现功能，A类直接拥有B类的对象，将参数传给B类也是能够实现功能的，但是就形成了强耦合关系，使用适配器模式主要是为了解耦合。在实际应用中我发现已经不自觉地使用了该设计模式，也算是比较常用的设计模式，只是这里抽象出来了而已。</p>
</blockquote>
<h3 id="delegate是对象适配器"><a href="#delegate是对象适配器" class="headerlink" title="delegate是对象适配器"></a>delegate是对象适配器</h3><p>如果用delegate来实现适配器模式的话，那么从分类上来说应该是对象适配器，Demo这里就没有写，一般我们使用delegate的时候很大部分情况是适配器模式。</p>
<h3 id="Block实现对象适配器"><a href="#Block实现对象适配器" class="headerlink" title="Block实现对象适配器"></a>Block实现对象适配器</h3><p>使用delegate的方法都是可以用block来改写了，那么这里就不多说了。</p>
<h3 id="何时使用-2"><a href="#何时使用-2" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>已有类的接口与需求不匹配。</li>
<li>想要一个可复用的类，该类能够同可能带有不兼容接口的其他类协作。</li>
<li>需要适配一个类的几个不同子类，可是让每一个子类去子类化一个类适配器又不实现。那么可以使用对象适配器（也叫委托）来适配其父类的接口。</li>
</ul>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p>将抽象部分与他的实现部分分离，使他们可以独立的变化。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式"></p>
<p>桥接模式简单的说就是将抽象部分与实现部分分离，但是根据不同的需求有很多不同的是实现方式，使用起来比较灵活。<a href="https://github.com/lixuzong/BridgePattern" target="_blank" rel="external">Demo地址在这</a>。与书上的代码稍微有些差异，因为通过抽象父类来调用具体子类的方式上有疑问，这里是给父类添加了一个初始化方法，在这个方法里面直接返回子类的对象。（有点像工厂模式）。</p>
<h3 id="何时使用-3"><a href="#何时使用-3" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>不想在抽象与其实现之间形成固定的绑定关系（这样就能在运行时切换实现）。</li>
<li>抽象及其实现都应通过子类化独立进行扩展。</li>
<li>对抽象的实现进行修改不应该影响客户端代码。</li>
<li>如果每个实现需要额外的子类以细化抽象，则说明有必要把他们分成两个部分。</li>
<li>想要带有不同抽象接口的多个对象之间共享一个实现。</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p>为系统中的一组接口提供一个统一的接口。外观定义一个高层接口，让子系统更容易使用。</p>
</blockquote>
<p>简单的说就是将一组功能抽象出来，只对外暴露一个接口。高度的抽象。</p>
<h3 id="何时使用-4"><a href="#何时使用-4" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>子系统正在逐渐变得复杂。应用模式过程中演化出许多类。可以使用外观为这些子系统提供给一个较简单的接口。</li>
<li>可以使用外观对子系统分层。每个子系统级别有一个外观作为入口点。让它们通过其外观进行通信，可以简化他们的依赖关系。</li>
</ul>
<h1 id="对象去耦"><a href="#对象去耦" class="headerlink" title="对象去耦"></a>对象去耦</h1><ul>
<li>中介者</li>
<li>观察者</li>
</ul>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><blockquote>
<p>中介者模式： 用一个对象来封装一系列对象的交互方式。中介者使得个对象不需要显示的相互引用，从而使得耦合松散，而且可以独立地改变他们之间的交互。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式"></p>
<p>简单的说就是单独使用一个对象C来管理A对象和B对象之间的交互或者说将A和B中较为复杂的逻辑抽象出来。减少A和B之间的耦合，便于A和B对象的重用。</p>
<h3 id="何时使用中介者模式"><a href="#何时使用中介者模式" class="headerlink" title="何时使用中介者模式"></a>何时使用中介者模式</h3><ul>
<li>对象之间的交互虽然定义明确但是非常复杂，导致一组对象项目依赖并且难以理解。</li>
<li>因为对象引用了许多其他对象并与其通信，导致对象难以复用。</li>
<li>想要定制一个分布在多个类中的逻辑或行为，又不想生成太多的子类。</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p>
<p>观察者模式在iOS里面的使用频率比较多，框架也已经帮我们实现了方便使用的方式。首先是NSNotificationCenter，再者还有KVO，所以基本已经可以满足我们的需求。目的就是解除观察者和被观察者之间的关系。</p>
<h1 id="抽象集合"><a href="#抽象集合" class="headerlink" title="抽象集合"></a>抽象集合</h1><ul>
<li>组合</li>
<li>迭代器</li>
</ul>
<h2 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h2><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="树形结构"></p>
<p>我们可以看到如上图所示的一个树形就够就是组合模式，在这个树形结构当中，线段既包含节点，也包换线段，但是client使用的时候并不关心Stroke包含什么，只是想要统一的处理。所以组合模式可以对外操作保持一致性。</p>
<p>在CocoaTouch中一个非常典型的例子就是UIView。UIView可以嵌套UIView，Client只需要对父View做响应的处理，父View就可以递归的调用子View，像渲染视图的命令，父View接收到只之后就会逐级向下传递。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示</p>
</blockquote>
<p>苹果公司用自己的命名规则“枚举器/枚举”改写了迭代器模式，用于相关基础类的方法。基础框架中的NSEnumerator类实现了迭代器模式。NSArray，NSSet，NSDictionary这样的集合类，定义了返回与集合的类型想响应的NSEnumerator子类实例的方法。用我这种比较通俗的说法就是，提供了一种遍历集合类的方法。也就是迭代器模式。</p>
<blockquote>
<p>基本上有两种迭代器：外部迭代器和内部迭代器。外部迭代器让client直接操作迭代过程，所以client需要知道外部迭代器才能使用。另一种情况是，集合对象（被迭代的目标对象）在其内部维护并操作了一个外部迭代器。提供内部迭代器的典型的集合对象为client定义一个接口，或者从底层集合一次访问一个元素，或者向每个元素发送消息。比如NSArray 的  <em>- （void）makeObjectsPerformSelector:(SEL)aSelector</em> 就是内部迭代器。就是不需要知道迭代器，在内部都遍历并实现操作。</p>
</blockquote>
<h3 id="何时使用-5"><a href="#何时使用-5" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>需要访问组合对象的内容，而又不暴露内部表示。</li>
<li>需要通过多种方式暴露组合对象。</li>
<li>需要提供一个统一的接口，来遍历各种类型的组合对象。</li>
</ul>
<h1 id="行为扩展"><a href="#行为扩展" class="headerlink" title="行为扩展"></a>行为扩展</h1><ul>
<li>访问者模式</li>
<li>装饰</li>
<li>责任链</li>
</ul>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="访问者模式"></p>
<p>解释一下访问者模式，就是将自己不熟悉的业务承包出去。比如说我们的家是一个类，对于里面的下水道我们就有各种使用的方法，但是关于修理下水道我们要承包出去，找专业的人来对他进行操作，而这个维修的操做不能影响我们现在的使用。所以这就是访问者模式，承包商就是访问者。这样比较容易理解。<br>从类图上可以看出来，Element调用 <em>acceptVister:</em> 方法将自身传递给vister，vister接收之后就可以对其进行操作。从而可以获得行为的扩展。</p>
<h3 id="何时使用访问者模式"><a href="#何时使用访问者模式" class="headerlink" title="何时使用访问者模式"></a>何时使用访问者模式</h3><ul>
<li>一个复杂的对象结构包含很多其他的对象，它们有不同的接口（比如组合体），但是相对这些对象实施一些依赖其具体类型的操作。</li>
<li>需要对一个组合结构中的对象进行很多不相关的操作，但是不想让这些操作“污染”这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。</li>
<li>定义复杂结构的类很少作修改，但是经常需要向其添加新的操作。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS知识点汇总(持续更新...)]]></title>
      <url>http://lixuzong.com/2016/08/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>记录开发过程中遇到的小知识点。<br><img src="http://odbghk3il.bkt.clouddn.com/draw_dog.jpeg" alt="狗"><br><a id="more"></a></p>
<h2 id="JDNetLog-s-…-引发的问题"><a href="#JDNetLog-s-…-引发的问题" class="headerlink" title="JDNetLog(s,…)引发的问题"></a>JDNetLog(s,…)引发的问题</h2><p>在做自己的项目的时候，一遍都会重新定义NSLog宏，方便在发布的时候将打印的log去除。这里就不多少了，首先贴上代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define JDNetLog(s, ...) [[JDiPadNetworkingLog sharedNetworkingLog] file:__FILE__ function: (char *)__FUNCTION__ \</span></span><br><span class="line">lineNumber:__LINE__ format:(s),<span class="meta">##__VA_ARGS__]</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)file:(<span class="keyword">char</span>*)sourceFile function:(<span class="keyword">char</span>*)functionName lineNumber:(<span class="keyword">int</span>)lineNumber format:(<span class="built_in">NSString</span>*)format, ...</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">NSString</span> *print, *file, *function;</span><br><span class="line"><span class="comment">//    NSMutableString *mStr = [NSMutableString string];</span></span><br><span class="line">    va_start(ap,format);</span><br><span class="line">    file = [[<span class="built_in">NSString</span> alloc] initWithBytes:sourceFile length:strlen(sourceFile) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    function = [<span class="built_in">NSString</span> stringWithCString: functionName encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="comment">//    if (format) &#123;</span></span><br><span class="line"><span class="comment">//        do &#123;</span></span><br><span class="line"><span class="comment">//            [mStr appendString:[NSString stringWithFormat:@"%@",format]];</span></span><br><span class="line"><span class="comment">//            format = va_arg(ap, id);</span></span><br><span class="line"><span class="comment">//        &#125; while (format);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//问题的根源就是没有理解这个函数！</span></span><br><span class="line">    print = [[<span class="built_in">NSString</span> alloc] initWithFormat:format arguments:ap];</span><br><span class="line"><span class="comment">//    print = [mStr copy];</span></span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_dateformatter) &#123;</span><br><span class="line"></span><br><span class="line">        _dateformatter=[[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [_dateformatter setDateStyle:<span class="built_in">NSDateFormatterShortStyle</span>];</span><br><span class="line">        [_dateformatter setDateFormat:<span class="string">@"yyyy-MM-dd HH:mm:ss.SSS"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *date = [_dateformatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    [<span class="keyword">self</span> addLog:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"\n[%@]\n%@:%d\n%@;\n%@\n"</span>,date ,[file lastPathComponent], lineNumber, function, print]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先说一下 <em>…</em> 这个函数，在iOS里面，这个表示的是可变的参数类型，也就是不定参数个数。处理的方法是用C语言的语法<em>va_list, va_start, va_end,va_arg(ap,type)</em> 首先声明一个 <em>va_list</em> ,使用 <em>va_start</em> 方法初始化这个 <em>va_list</em> ,也就是传入第一个参数的指针进行初始化，<em>va_arg</em>就是来将指针指向下一个参数，这样就可以根据链条一直找到最后一个参数，最后就 <em>va_end</em> 就结束了。这里主要是对 <em>print = [[NSString alloc] initWithFormat:format arguments:ap];</em> 函数理解错误了，看到这个函数传的是首指针的地址和 <em>va_list</em> ，之前自以为是以为是将之后传的所有参数都与前面拼接之后生成一个字符串，其实并不是这样，这个方法与 <em>[NSString stringWithFormat:@”%@”,format]</em> 类似，只是将前面的format与arguments分开了而已，也是要遵循 <em>@”%@%@”,argument1, argument2</em> 这样的格式，所以函数里传入的 <em>va_list</em> 只是符合这个格式 <em>arguments</em> ，并不是我们传递进去的 <em>va_list</em>。所以在使用 <em>JDNetLog(s,…)</em> 时要注意传入的格式。</p>
<h2 id="关于面向接口编程"><a href="#关于面向接口编程" class="headerlink" title="关于面向接口编程"></a>关于面向接口编程</h2><p>今天完成了任务之后，突然想到了在书上看到的面向接口编程，而不是面向对象编程，也是困惑了一段时间（尼玛，老子在学校学的都是面向对象，你现在有不用了？）。今天大概了解了一下，其实并不是要抛弃面向对象的思想，而是减少对象依赖。简单的说就是不要在其他类中直接使用对象的属性，而是包装一层在接口里面，直接使用接口。针对iOS来说就是尽量的将对象的属性封装成接口之后，对外暴露接口，而不是对外暴露属性。既然是面向接口编程，那么最彻底的就是使用@protocol了，因为@protocol就是将接口抽象出来。这里主要参考了<a href="http://www.olinone.com/?p=429" target="_blank" rel="external">这篇文章</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native开源项目笔记(1):redux管理数据]]></title>
      <url>http://lixuzong.com/2016/07/15/react-native%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>首先放上开源项目的地址：<a href="https://github.com/ljunb/react-native-iShiWuPai" target="_blank" rel="external">React-Native开源项目iShiWuPai</a><br>这边笔记主要是记录看开源项目iShiWuPai之后的一些知识点。前端的话一般都是使用的MVC框架，这样的话我也是从这三个方面学习，这个项目中的数据的话用的是Redux框架，View的话就是使用ReactNative框架。</p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/shouhui2.jpg" alt="手绘"></p>
<a id="more"></a>
<h2 id="index-ios-js文件"><a href="#index-ios-js文件" class="headerlink" title="index.ios.js文件"></a>index.ios.js文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> Root <span class="keyword">from</span> <span class="string">'./app/root'</span>;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'iShiWuPai'</span>, () =&gt; Root);</span><br></pre></td></tr></table></figure>
<p><em>Root</em> 文件是主入口，<em>AppRegister.registerComponent（）</em> 方法是用来注册ReactNative，第一个字符串要和iOS项目中注册的一致，第二个传入的是根类。</p>
<blockquote>
<p>这里的 <em>()=&gt;Root</em> 的写法有点像iOS的Block块，姑且当做是JS里面匿名函数的写法吧。</p>
</blockquote>
<h2 id="root-js文件"><a href="#root-js文件" class="headerlink" title="root.js文件"></a>root.js文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="comment">//这个是结构化好的state数据</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/store'</span>;</span><br><span class="line"><span class="comment">//这个是项目的主要逻辑</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Provider store = &#123;store&#125; &gt;</span><br><span class="line">                 &lt;App /&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用到了<em>react-redux</em>文件，<em>redux</em> 主要是用来处理数据，管理state而存在的，将工程中使用的所有state结构化成树结构，这样的话就可以跟踪state的变化（大概就先了解这么多，以后再具体研究）。使用方法大概就是引入 <em>Provider</em> 类，并且将准备好的 <em>store</em>（就是已经结构化好的数据）传入。刚开始学习的时候不太懂怎么使用其他文件中的类的，这里看到 <em>export</em> 关键字就联系到了iOS中的 <em>public</em> 关键字，这样的话只要导入这个文件之后就可以直接使用 <em>export</em> 修饰的类了。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>这里参考了文章：<a href="https://rhadow.github.io/2015/07/30/beginner-redux/" target="_blank" rel="external">redux入门</a></p>
<h3 id="store-js文件"><a href="#store-js文件" class="headerlink" title="store.js文件"></a>store.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'../reducers/rootRudcer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line"><span class="keyword">let</span> store = createStoreWithMiddleware(rootReducer);</span><br><span class="line"><span class="comment">// let state = store.getState();</span></span><br><span class="line"><span class="comment">// alert(state.Search.searchText)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>这里 <em>redux</em> 和 <em>redux-thunk</em> 的使用方法就是像代码里写的一样。<em>reducer</em> 是用来管理 <em>state</em> 和 <em>action</em> 类，这里每个页面的数据就是使用一个 <em>reducer</em> ，<em>rootReducer</em> 是各个 <em>reducer</em> 的集合。 <em>action</em> 是用来更新 <em>state</em> 的，因为将所有的state都集中在一起管理，那么用 <em>action</em> 来更新 <em>state</em> 就不会产生混乱了。就是可以理解成 <em>reducer</em> 提供了一个容器，在这个容器里面用 <em>action</em> 来更新 <em>state</em> 。<em>let store = createStoreWithMiddleware(rootReducer);</em> 这句换就是将 <em>reducer</em> 和 <em>store</em> 发生关联，这样当 <em>store</em> 里面的数据发生改变的时候就会触发 <em>Action</em> 事件。</p>
<blockquote>
<p>middleware是用来实现 <em>dispatch</em> 方法的异步或者同步执行等不同的状态，这里使用的是异步的 <em>dispatch</em> 方法。</p>
</blockquote>
<p><img src="http://user-image.logdown.io/user/8925/blog/8821/post/332288/tPbal8BSc6vs06ti0FVQ_Redux-multi-reducer.jpg" alt="更新state流程"></p>
<p><img src="http://user-image.logdown.io/user/8925/blog/8821/post/332288/NqajldzQTpWbXR3YjEyN_Redux-middleware.jpg" alt="middleware作用"></p>
<h3 id="strollingReucer-js"><a href="#strollingReucer-js" class="headerlink" title="strollingReucer.js"></a>strollingReucer.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义所有types的地方</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../actions/actionTypes'</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    bannerList: [],</span><br><span class="line">    feedList: [],</span><br><span class="line">    isLoading: <span class="literal">true</span>,</span><br><span class="line">    isLoadMore: <span class="literal">false</span>,</span><br><span class="line">    isRefreshing: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strollingReducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> types.FETCH_BANNER_LIST:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> types.RECEIVE_BANNER_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                bannerList: action.bannerList,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">case</span> types.FETCH_FEED_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                isLoadMore: action.isLoadMore,</span><br><span class="line">                isRefreshing: action.isRefreshing,</span><br><span class="line">                isLoading: action.isLoading,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">case</span> types.RECEIVE_FEED_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                feedList: state.isLoadMore ? state.feedList.concat(action.feedList) : action.feedList,</span><br><span class="line">                isRefreshing: <span class="literal">false</span>,</span><br><span class="line">                isLoading: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> strollingReducer;</span><br></pre></td></tr></table></figure>
<p><em>reducer</em> 的任务就是将传入的旧 <em>state</em> 和 <em>action</em> 更新并返回新的 <em>state</em> 。示例代码中的 <em>strollingReducer</em> 就是 <em>rootReducer</em> 中的一个。</p>
<h3 id="strollingActions-js文件"><a href="#strollingActions-js文件" class="headerlink" title="strollingActions.js文件"></a>strollingActions.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'./actionTypes'</span>;</span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../common/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> fetchBanners = ()=&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> URL = <span class="string">'http://food.boohee.com/fb/v1/home/banners'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch =&gt; &#123;</span><br><span class="line">        <span class="comment">// 请求轮播数据</span></span><br><span class="line">        dispatch(fetchBannerList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Util.get(URL, (response) =&gt; &#123;</span><br><span class="line">            dispatch(receiveBannerList(response.banners))</span><br><span class="line">        &#125;, (error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Fetch banner list error: '</span> + error);</span><br><span class="line">            dispatch(receiveBannerList([]));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fetchBannerList = ()=&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: types.FETCH_BANNER_LIST,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> receiveBannerList = (bannerList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: types.RECEIVE_BANNER_LIST,</span><br><span class="line">        bannerList: bannerList,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是对应的的 <em>strolling</em> 类的 <em>action</em> 文件,这里需要更新 <em>state</em> 的情况就是加载网络数据之后更新。之前一直在想 <em>strollingAction</em>  是如何将自身传递给 <em>strollingReducer</em> 的，这里是自己理解的 <em>dispatch</em> 的作用。既然最后要将 <em>reducer</em> 合并成一个，这样的话 <em>dispatch</em> 直接操作的是 <em>state</em> 树结构，所有的 <em>action</em> 也都会返回一个固定的结构:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> receiveBannerList = (bannerList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: types.RECEIVE_BANNER_LIST,</span><br><span class="line">        bannerList: bannerList,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回的就是一个 <em>action</em> ，格式基本上就是这样。</p>
<h3 id="Strolling-js文件"><a href="#Strolling-js文件" class="headerlink" title="Strolling.js文件"></a>Strolling.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">        InteractionManager.runAfterInteractions(() =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;dispatch&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">            dispatch(fetchBanners());</span><br><span class="line">            dispatch(fetchFeeds(page, canLoadMore, isRefreshing, isLoading));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123;Strolling&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> bannerList = Strolling.bannerList;</span><br><span class="line">        <span class="keyword">let</span> feedList = Strolling.feedList;</span><br><span class="line">        <span class="keyword">let</span> sourceData = &#123;<span class="string">'banner'</span>: [bannerList], <span class="string">'feed'</span>: feedList&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> sectionIDs = [<span class="string">'banner'</span>, <span class="string">'feed'</span>];</span><br><span class="line">        <span class="keyword">let</span> rowIDs = [[<span class="number">0</span>]];</span><br><span class="line">				...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在 <em>Strolling</em> 中使用数据的时候有两个个地方没有看明白， <em>const {dispatch} = this.props</em> 和 <em>const {Strolling} = this.props</em> 。通过查 <em>redux</em> 文档，原来这个地方能从props里直接取到 <em>dispatch</em> 和 <em>Strolling</em> 是因为框架调用了React Redux connect()注入props。这样的话就做到了数据的传输使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以iOS开发的角度了解HTTP协议]]></title>
      <url>http://lixuzong.com/2016/06/23/%E4%BB%8EiOS%E5%BC%80%E5%8F%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3HTTP/</url>
      <content type="html"><![CDATA[<p>目前做iOS开发以来，使用的都是HTTP协议，所幸现在接触到的东西还是之前的知识储备所能够应付的，正好趁着还没有入职的这段时间补充点这方面的知识，当然还是从我比较熟悉的iOS的角度来进行学习。最近看的书是《图解HTTP》，也算是看了该书的一个总结吧。</p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/HTTP_book" alt="shouhuiImage"></p>
<a id="more"></a>
<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>首先TCP/IP协议族不仅包括了TCP协议和IP协议，而是很多协议的总称。TCP/IP协议按照层次分为4层，分别是：应用层、传输层、网络层和数据链路层。HTTP协议在应用层，之后是传输层的TCP协议，然后是网络层的IP协议，数据链路层是与硬件相关的协议。HTTP协议规定一端是客户端，一端是服务器，这样的话数据流从客户端从上至下传输，每经过一层就加上报文头，到了服务器端之后数据流就会从下至上逐成解析。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>为了准确无误的将数据送到目标处，并且能够确认数据最终是否送达到对方。为了实现这个目标，TCP采用三次握手的方式。</p>
<p>结合实际中的例子比较容易理解三次握手是怎么实现的。比如在古代，A托商队给B一个东西，并且双方都要确认这条线路的安全性，那么A在这个东西里面放了一个标志SYN，B收到之后在东西里面放置了ACK表明B已经知道了，商队回来的时候将东西交还给A，A会看到自己放置的SYN和B放置的ACK，这样的话A就可以确认这条道路的安全性，但是这个时候B并不知道A收到了数据，所以这个时候A还需要在东西里放置ACK给B表明A收到了东西。简单的说就是每个端发送出东西的时候都要获得回应才能确认东西到达，所以就是三次。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议的作用就是把各种数据包传给对方。为了能确保准确送达，所以需要IP地址和MAC地址，IP地址指明了节点被分配的地址，MAC地址指的是网卡所属的固定地址，IP地址可变换，但是MAC地址是不会改变的。所以IP间的通信就需要MAC地址，这里就需要知道IP地址和MAC地址的对应关系，所以又出现了另一种协议ARP（Address Resolution Protocol），能通过IP地址查询到MAC地址。</p>
<h3 id="HTTP数据流程图"><a href="#HTTP数据流程图" class="headerlink" title="HTTP数据流程图"></a>HTTP数据流程图</h3><p><img src="http://o835bn5qj.bkt.clouddn.com/IMG_3842.JPG" alt="HTTP"></p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>首先先接受几个和HTTP相关的短语。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p>
<blockquote>
<p>在开发过程中经常需要翻墙，也就是使用在国外的代理，这样的话就可以正常访问国外的网站了。</p>
</blockquote>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是转发其他服务器通信数据的服务器，接收从客户端接收到的请求之后会对请求进行处理，有时候客户端本身并不知道自己对接的是一个网关。</p>
<h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>HTTP协议首先是客户端和服务器之间的协议，在没有扩展协议的情况下只能从客户端发起请求然后服务端返回响应。</p>
<table>
<thead>
<tr>
<th>请求报文首部</th>
<th>响应报文首部</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求行</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>请求首部字段</td>
<td>通用首部字段</td>
</tr>
<tr>
<td>通用首部字段</td>
<td>实体首部字段</td>
</tr>
<tr>
<td>实体首部字段</td>
<td>其他</td>
</tr>
<tr>
<td>其他</td>
</tr>
</tbody>
</table>
<p>这是一个简单的示意图，分别展示了请求报文首部和响应报文的首部。这里可以看到通用首部字段和实体首部字段这两个部分是相同的，只是在请求首部字段和响应首部字段会有区别。</p>
<blockquote>
<p>GET / HTTP/1.1<br>Host: hackr.jp<br>User-Agent: Mozilla/5.0<br>Accept: text/html, application/xml;q=0.9<br>Accept-language: ja, en-us</p>
</blockquote>
<p>这里列举了几个我们经常看到的请求报文首部参数，这里写明了请求是GET方法的请求，使用的是HTTP/1.1协议，请求的地址是<em>hackr.jp</em>，客户端接收的数据是HTML数据…各种首部非常多，在用到的时候可以查阅相关的资料。</p>
<h3 id="iOS中会用到的首部"><a href="#iOS中会用到的首部" class="headerlink" title="iOS中会用到的首部"></a>iOS中会用到的首部</h3><p>HTTP/1.1协议中有很多的首部，但是大部分是针对浏览器来使用的，就目前的知识储备来看，在iOS开发当中有用到的首部有请求首部If-Match和响应首部的Etag配合使用来做网络缓存；还有HTTP的扩展协议Cookie来记录用户的登陆状态。</p>
<h4 id="If-Match-amp-Etag"><a href="#If-Match-amp-Etag" class="headerlink" title="If-Match &amp; Etag"></a>If-Match &amp; Etag</h4><p>之前看过一篇文章讲的是iOS缓存，其中有一个讲到的就是利用HTTP协议自带的网络缓存来实现。</p>
<blockquote>
<p>If-Match: “123456”</p>
</blockquote>
<p>只有当服务器资源的Etag的值为 <em>“123456”</em> 时，才会对客户端的请求作出响应，因为资源的更新那么Etag值就会发生更新，所以可以识别出资源是否已经更新或者已经过期。</p>
<h4 id="If-Modifield-Since"><a href="#If-Modifield-Since" class="headerlink" title="If-Modifield-Since"></a>If-Modifield-Since</h4><p>这个参数是请求报文首部中的参数，可以指定资源的有效时间，从字面上就可以看出如果从给出的时间上没有更新的话，服务器就会返回 <em>304 Not Modifield</em> ,如果有更新就会返回资源并且响应首部上也会加上 <em>Last-Modifield: last time</em></p>
<h4 id="Cookie-amp-amp-Set-Cookie"><a href="#Cookie-amp-amp-Set-Cookie" class="headerlink" title="Cookie &amp;&amp; Set-Cookie"></a>Cookie &amp;&amp; Set-Cookie</h4><p>Cookie是请求报文首部字段，Set-Cookie是响应报文首部字段。首先是服务器返回Set-Cookie字段将Cookie值返回给客户端，客户端每次请求的时候将该值赋值给Cookie字段，用这种形式来确定用户登录。我们在开发iOS客户端的时候往往需要使用Token来实现用户登录，我们可以利用HTTP的这个属性来进行认证。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>由于iOS要求全面要支持https协议，所以还是有必要了解下什么是HTTPS协议。</p>
<blockquote>
<p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p>
</blockquote>
<p>HTTPS并非是一个新的协议，只是HTTP通信接口部分使用SSL和TLS协议代替而已。HTTP是直接和TCP通信，HTTPS是先和SSL通信，SSL和TCP通信，所以说HTTPS就是套了一层SSL协议外壳的HTTP协议。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>iOS开发中对各种各样的证书并不陌生，有开发者证书、发布证书、推送证书等等…  </p>
<p>要了解证书首先要知道非对称加密算法。非对称加密算法就是A经过一个固定的运算可以得到B，并且通过B可以得到A，利用这个数学公式，我们就可以用A来对数据加密，用B来对数据解密。这是基于这样的一个数学公式而产生的算法。这样的话就可以公开A或者B中的一个，被公开的那个就是公钥，保留的要私钥，这样的话谁都可以用公钥来加密，但是能解密的只有私钥。  </p>
<p>证书就是用来保存公钥的，且证明公钥的有效性。因为公钥是要发布出去的，但是公钥也需要证明其自身是有效的，这样的话就产生了证书。证书原本的意思就是权威机构发布的能有效证明的文件，那么这里的证书也是同样的道理。是权威机构发布的对公钥有效性的证明文件。这里的权威机构是被大家所认可的几家机构，如果是想要提交公钥来开具证书是需要收费的，所以Apple公司为了安全性还是挺舍得花钱的。</p>
<h3 id="HTTPS的认证过程"><a href="#HTTPS的认证过程" class="headerlink" title="HTTPS的认证过程"></a>HTTPS的认证过程</h3><p><img src="http://o835bn5qj.bkt.clouddn.com/https.JPG" alt="https"></p>
<blockquote>
<p>最后在iOS开发中如果遇到http问题的时候再进行补充。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native从最基础学起]]></title>
      <url>http://lixuzong.com/2016/06/13/React%20Native%E4%BB%8E%E6%9C%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E8%B5%B7%20/</url>
      <content type="html"><![CDATA[<p>这篇文章主要讲的的内容是没有JavaScript基础的情况下开发React Native应用需要知道的基础知识。也是我在学习React Native框架的一个学习曲线。以方便记录下来方便查阅，一方面希望可以帮助到和我一样的菜鸟减少学习时间。</p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/shouhui1.jpg" alt="shouhuiImage"></p>
<a id="more"></a>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h3><p>var声明的变量是无视作用域的，而let是在作用域里有效的。</p>
<blockquote>
<p>这里需要和swift中的var和let区分，var是是可以改变的值，而let是不可以改变的值，与作用域无关。</p>
</blockquote>
<h3 id="匿名函数的写法"><a href="#匿名函数的写法" class="headerlink" title="匿名函数的写法"></a>匿名函数的写法</h3><p>与swift语法一样，函数也是对象类型，也可作为函数的返回值来只用，但是匿名函数的写法有所不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (valueA, valueB) =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> valueA +valueB;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addFunc()(<span class="number">1.2</span>)); <span class="comment">//输出3</span></span><br></pre></td></tr></table></figure>
<h3 id="与-的区别"><a href="#与-的区别" class="headerlink" title="==与===的区别"></a>==与===的区别</h3><p>与其他语法不同点是==比较左右的值，只要值相等，结果就是true。而===不仅比较值，也比较类型，只有两者相等才返回true。</p>
<blockquote>
<p>‘!=’是值不相等，‘！==’是值和类型都不相等</p>
</blockquote>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul>
<li>this 关键字表示类对象本身，如果在类内使用函数之类通过this来调用</li>
<li>类的构造函数<em>constructor(valueA,valueB)</em>创建类的使用调用</li>
<li>可以通过<em>static</em>和<em>Class.obj</em>两种方式创建静态变量</li>
<li>类中定义的函数可以省略关键字<em>function</em></li>
<li>通过<em>this.obj</em>来创建字段，可以在类的构造函数里面创建也可以在函数外创建，如果是未创建的字段其值为<em>undefined</em></li>
<li>字段的只读和只写属性通过<em>get</em>和<em>set</em>关键字来声明，这里可以跟objective-C的方法类比。</li>
<li>类的继承使用extend关键字，在子类里调用super就可以调用父类的函数。</li>
<li>对象使用new来生成，还有一种情况是直接生成匿名类对象，用键值对的形式创建对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   	name: <span class="string">'obj'</span>,</span><br><span class="line">   	value: <span class="string">'lalala'</span>,</span><br><span class="line">  	 	sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">       	<span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name);</span><br><span class="line">   	&#125;,</span><br><span class="line">   	sayHi: (name) =&gt; &#123;</span><br><span class="line">       	<span class="built_in">console</span>.log(<span class="string">'Hi! '</span> + name);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="文件的导入和导出"><a href="#文件的导入和导出" class="headerlink" title="文件的导入和导出"></a>文件的导入和导出</h2><p>首先说一下相对路径，使用 . 就是在当前路径查找，如果是..就是从上层路径查找，没有 . 或者 / 开头的就是从项目根目录开始查找。</p>
<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>导出的时候需要使用<em>export</em>关键字,可以到出变量、类、函数，可以定义默认导出内容，需要加上<em>export default</em>关键字</p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>导入文件使用关键字<em>import</em>,<em>from</em>格式是 <em>import [something] from ‘相对路径’</em> 。如果是没有使用默认导出的情况下可以根据需要接收需要的属性，一般是全部接收，如果有默认导出的话可以直接接收默认导出，并且默认导出是唯一的！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'lala'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> age = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 如果只需要 value 和 name</span></span><br><span class="line"><span class="keyword">import</span> &#123;value, name&#125; <span class="keyword">from</span> <span class="string">'./data.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想将所有由 export 导出的都引入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> data <span class="keyword">from</span> <span class="string">'./data.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data.value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入可以任意取名</span></span><br><span class="line"><span class="keyword">import</span> anyName <span class="keyword">from</span> <span class="string">'./data.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyName);	</span><br></pre></td></tr></table></figure>    
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><img src="http://o835bn5qj.bkt.clouddn.com/reactnativeLifeCycle.png" alt="liftCycle"><br>在整个ReactJS的生命周期中，主要经历4个阶段：创建阶段、实例化阶段、更新阶段和销毁阶段。</p>
<h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>   这个阶段会调用<em>getDefaultProps</em>方法，并返回一个对象缓存下来，然后与父组件制定的props对象合并，最后赋值给this.props作为默认属性。</p>
<blockquote>
<p><em>props</em>是一个对象，是组件用来接收外面参数的，不支持在内部修改自己的<em>props</em>属性,只能通过父组件来赋值。<em>getDefaultProps</em>方法是用来设置默认值得。</p>
</blockquote>
<h3 id="实例化阶段"><a href="#实例化阶段" class="headerlink" title="实例化阶段"></a>实例化阶段</h3><p>该阶段是在实例化组件类的时候，也就是该组件类被调用的时候。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render (</span><br><span class="line">	&lt;List name = "ReactJS"&gt;&lt;/List&gt;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们初始化了一个<em>List</em>组件，这个时候看一下依次调用的生命周期方法。</p>
<ol>
<li><em>getInitialState</em> 初始化组件的state值，其值会被赋值给this.state属性。</li>
<li><em>componentWillMount</em> 组件即将被加载到视图上的时候调用，根据业务对state进行相应的操作</li>
<li><em>render</em> 根据state的值，生成页面需要的虚拟DOM结构，并返回该结构。</li>
<li><em>componentDidMount</em> 对根据虚拟DOM结构而生成的真是DOM进行相应的处理。为了保证不出现UI上的错误，在这个函数里面发起请求接收网络数据。这个时候改变this.state属性就会出发ReactJS内部的监听事件，再次调用<em>getInitialState</em>函数，这样的话再次刷新界面。</li>
</ol>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>这主要发生在用户操作之后或者父组件有更新的时候，此时会根据用户的操作进行相应的调整。</p>
<ol>
<li><em>componentWillReceiveProps(object nextProps)</em> 当组件接收到新的<em>props</em>时，会触发该函数。在该函数中通常可以调用<em>this.state</em>完成对<em>state</em>的修改。</li>
<li><em>shouldComponentUpdate(nextProps nextState)</em> 该方法会拦截新的<em>props</em>和<em>state</em>，然后根据事先判定好的判断逻辑，做出最后要不要更新组件的决定。</li>
<li><em>componentWillUpdate(object nextProps, object nextState)</em> 当方法2返回的是true的时候这里就做一些更新前的操作。</li>
<li><em>render</em> 根据一系列的diff算法，生成需要更新的虚拟DOM数据。最好在这里进行数据和模板的整合，不进行state的操作。</li>
<li><em>componentDidUpdate</em> 该方法在组件更新已经同步到DOM中后出发，我们通常在该方法中做一些DOM操作。</li>
</ol>
<h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p><em>componentWillUnmount</em> 当组件从DOM中移除的时候调用这个方法，通常会在这个方法中做一些取消事件绑定，销毁定时器等工作。</p>
<blockquote>
<p>就相当于iOS中的dealloc函数。   </p>
</blockquote>
<h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h2><p><a href="http://blog.csdn.net/yuanguozhengjust/article/details/50470171" target="_blank" rel="external">http://blog.csdn.net/yuanguozhengjust/article/details/50470171</a><br><a href="https://lzxhahaha.gitbooks.io/react-native-getting-start/content/index.html" target="_blank" rel="external">https://lzxhahaha.gitbooks.io/react-native-getting-start/content/index.html</a></p>
]]></content>
    </entry>
    
  
  
</search>
