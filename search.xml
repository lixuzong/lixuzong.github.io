<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[ios中的设计模式实现]]></title>
      <url>http://lixuzong.com/2016/08/15/ios%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>大部分的Demo可以在这里查看：<a href="https://github.com/lixuzong/iosPatternDemo" target="_blank" rel="external">Demo在这里</a></p>
<p>首先先讲一下大概的设计模式的分类。</p>
<ul>
<li>1、对象创建，主要是生成对象的方法。</li>
<li>2、接口适配，为了解决两个类之间接口不吻合</li>
<li>3、对象去耦，对象去耦合有利于代码的复用</li>
<li>4、抽象集合，将要用的组合抽离出来，主要有组合模式</li>
<li>5、行为扩展，在已有功能的基础上扩展功能</li>
<li>6、算法封装</li>
</ul>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E4%B9%A6.png" alt="设计模式"></p>
<a id="more"></a>
<h1 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h1><ul>
<li>原型</li>
<li>工厂方法</li>
<li>抽象工厂</li>
<li>生成器</li>
<li>单例</li>
</ul>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><blockquote>
<p>工厂方法模式： 定义创建对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到其子类。</p>
</blockquote>
<p>首先先看一下类图：<br><img src="http://o835bn5qj.bkt.clouddn.com/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.png" alt="工厂方法"></p>
<p>通过类图可以很清楚的看到，有一个product对象需要被创建，创建对象的方法来自于继承子类重写Creator，也就是说需要知道子类的具体类型才能够进行创建。</p>
<p>在<a href="http://item.jd.com/11402853.html" target="_blank" rel="external">《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》</a>中也有提及到的虚拟工厂方法，在iOS里面叫做类族，比较典型的类就是我们经常使用的NSArray类，通常我们会认为NSArray是一个类，提供了一些方法，但是在NSArray类里面获得确实其子类的实例，这就是一个典型的工厂模式。</p>
<h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>编译时无法准确预期要创建的对象的类。</li>
<li>类想让其子类决定在运行时创建什么。</li>
<li>类若有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化。</li>
</ul>
<h2 id="抽象工程模式"><a href="#抽象工程模式" class="headerlink" title="抽象工程模式"></a>抽象工程模式</h2><blockquote>
<p>提供一个创建一系列相关或者相互依赖的接口的对象，而无需指定他们具体的类。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.png" alt="抽象工厂"></p>
<p>通过类图我们可以看出，client通过抽象工厂来创建ProductA和ProductB，但是client只要通过AbstractFactory就可以直接获得其子类，而不需要知道子类。这就是为什么是抽象工厂，在工厂方法的基础上隐藏了其实现的具体子类，在工厂方法的基础上又进行了一次抽象。</p>
<p>说到抽象工厂模式的话，就是要与工厂方法比较一下。</p>
<table>
<thead>
<tr>
<th>抽象工厂</th>
<th>工厂方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>通过对象组合创建抽象产品</td>
<td>通过类继承创建抽象产品</td>
</tr>
<tr>
<td>创建多系列产品</td>
<td>创建一种产品</td>
</tr>
<tr>
<td>必须修改父类的接口才能支持新的产品</td>
<td>子类化创建者并重载工厂方法以创建新的产品</td>
</tr>
</tbody>
</table>
<p>假设你现在正在看Demo的话，这里可以简单的说一下。其实抽象工厂就是在工厂方法的基础上将具体的类型也隐藏起来。所以工厂方法里需要知道之类的类型才能够创建对象，而抽象工厂不需要知道具体的子类的类型就可以直接通过父类的方法创建子类对象，所以是在工厂方法的基础上又抽象了一层。</p>
<h2 id="生成器模式"><a href="#生成器模式" class="headerlink" title="生成器模式"></a>生成器模式</h2><blockquote>
<p>生成器模式：将一个复杂对象的构建与他的表现分离，使得同样的构建过程可以创建不同的表现。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E7%94%9F%E6%88%90%E5%99%A8.png" alt="生成器模式"></p>
<p>通过类图我们可以看出来，Director与一个builder对象相识，是通过这个Builder对象来获取对象的。</p>
<p>根据我的理解，就是单独使用一个类来管理生成对象，client并不需要自己创建对象，只需要告诉生成器我需要什么样的对象，这样生成器就会根据需求创建响应的对象。这样的话就会将构建与表现分离了。<a href="https://github.com/lixuzong/BuilderPattern" target="_blank" rel="external">Demo在这里</a></p>
<h3 id="何时使用-1"><a href="#何时使用-1" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>需要创建设计各种部件的复杂对象。创建对象的算法应该独立于部件的装配方式。常见例子是构建组合对象。</li>
<li>构建过程需要以不同的方式（例如，部件或表现的不同组合）构建对象。</li>
</ul>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>单例模式： 保证一个类只有一个实例，并提供一个访问他的全局访问点。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E5%8D%95%E4%BE%8B.png" alt="单例模式"></p>
<p>单例模式是iOS里面比较常用的设计模式。一般我们平时要求不是很严格的时候是这样写的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)shareCharacter &#123;</span><br><span class="line">    static Character *character;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        character = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return character;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <em>dispatch_once</em> 是为了线程安全，这个也可以用加锁来解决，但一般是交给GCD来实现，会做部分的优化。为什么会说是不严格的单例的，主要是以下两个方面：</p>
<ul>
<li>发起调用的对象不能以其他分配方式实例化单例对象。否则，有可能创建单例的多个实例。</li>
<li>对单例对象实例化的限制应该与引用计数内存模型共存。</li>
</ul>
<p>因为ARC目前已经完全取代了MRC所以第二点也就没有必要考虑了，但是仍然需要考虑创建对象的唯一性。也看到有一种方式直接在其他创建对象的方法中强制抛出异常，个人认为是不可取的。一言不合就贴代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">static Character *character;</span><br><span class="line"></span><br><span class="line">+ (instancetype)shareCharacter &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        character = [[super allocWithZone:NULL] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return character;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (instancetype)allocWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return [self shareCharacter];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (instancetype)copy &#123;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里如要是对内存做了限制，首先说一下生成对象的两种方式 <em>[Character shareCharacter]</em> 和 <em>[[Character alloc] init]</em> 需要让两种方法都返回的是同一块内存地址，因为objective-c采用的是两段式的初始化方法，所有只要控制 <em>+ (instancetype)allocWithZone:(struct _NSZone </em>)zone* 返回同样的内存地址就可以了。</p>
<blockquote>
<p>这里碰到了一个疑惑就是在网上看到 <em>- (instancetype)copy {return self;}</em> 的另一个版本是 <em>- (instancetype)copy {return character;}</em> 就有点困惑self的指代问题，通过 <em>[self shareCharacter]</em> 可以看出self指代的是当前的类，怎么在返回的时候是一个对象那？后来查了下资料并结合ios runtime的特性，原来self是在运行的时候动态决定其指代的，可以是当前类，也可以是当前的对象。那么这里的理解就是在类方法里面就是当前类，在实例方法里面就是当前对象。</p>
</blockquote>
<h1 id="接口适配"><a href="#接口适配" class="headerlink" title="接口适配"></a>接口适配</h1><ul>
<li>适配器</li>
<li>桥接</li>
<li>外观</li>
</ul>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><blockquote>
<p>适配器模式：将一个类的接口转换成客户希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的类可以一起工作</p>
</blockquote>
<p>适配器模式在ios里面的实现分为两种，分别是类适配器和对象适配器。假设我们有A类，B类，把A类当成客户，但是A类不能直接调用B类的接口，所以需要一个适配器C类。</p>
<ul>
<li>类适配器：将适配器C类继承于B类，对A暴露相关功能的接口。</li>
</ul>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8.png" alt="类适配器"></p>
<ul>
<li>对象适配器：适配器C类拥有B类的实例，对A暴露相关功能的接口。</li>
</ul>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8.png" alt="对象适配器"></p>
<blockquote>
<p>在使用的过程中不使用适配器模式也能实现功能，A类直接拥有B类的对象，将参数传给B类也是能够实现功能的，但是就形成了强耦合关系，使用适配器模式主要是为了解耦合。在实际应用中我发现已经不自觉地使用了该设计模式，也算是比较常用的设计模式，只是这里抽象出来了而已。</p>
</blockquote>
<h3 id="delegate是对象适配器"><a href="#delegate是对象适配器" class="headerlink" title="delegate是对象适配器"></a>delegate是对象适配器</h3><p>如果用delegate来实现适配器模式的话，那么从分类上来说应该是对象适配器，Demo这里就没有写，一般我们使用delegate的时候很大部分情况是适配器模式。</p>
<h3 id="Block实现对象适配器"><a href="#Block实现对象适配器" class="headerlink" title="Block实现对象适配器"></a>Block实现对象适配器</h3><p>使用delegate的方法都是可以用block来改写了，那么这里就不多说了。</p>
<h3 id="何时使用-2"><a href="#何时使用-2" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>已有类的接口与需求不匹配。</li>
<li>想要一个可复用的类，该类能够同可能带有不兼容接口的其他类协作。</li>
<li>需要适配一个类的几个不同子类，可是让每一个子类去子类化一个类适配器又不实现。那么可以使用对象适配器（也叫委托）来适配其父类的接口。</li>
</ul>
<h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><blockquote>
<p>将抽象部分与他的实现部分分离，使他们可以独立的变化。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F.png" alt="桥接模式"></p>
<p>桥接模式简单的说就是将抽象部分与实现部分分离，但是根据不同的需求有很多不同的是实现方式，使用起来比较灵活。<a href="https://github.com/lixuzong/BridgePattern" target="_blank" rel="external">Demo地址在这</a>。与书上的代码稍微有些差异，因为通过抽象父类来调用具体子类的方式上有疑问，这里是给父类添加了一个初始化方法，在这个方法里面直接返回子类的对象。（有点像工厂模式）。</p>
<h3 id="何时使用-3"><a href="#何时使用-3" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>不想在抽象与其实现之间形成固定的绑定关系（这样就能在运行时切换实现）。</li>
<li>抽象及其实现都应通过子类化独立进行扩展。</li>
<li>对抽象的实现进行修改不应该影响客户端代码。</li>
<li>如果每个实现需要额外的子类以细化抽象，则说明有必要把他们分成两个部分。</li>
<li>想要带有不同抽象接口的多个对象之间共享一个实现。</li>
</ul>
<h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><blockquote>
<p>为系统中的一组接口提供一个统一的接口。外观定义一个高层接口，让子系统更容易使用。</p>
</blockquote>
<p>简单的说就是将一组功能抽象出来，只对外暴露一个接口。高度的抽象。</p>
<h3 id="何时使用-4"><a href="#何时使用-4" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>子系统正在逐渐变得复杂。应用模式过程中演化出许多类。可以使用外观为这些子系统提供给一个较简单的接口。</li>
<li>可以使用外观对子系统分层。每个子系统级别有一个外观作为入口点。让它们通过其外观进行通信，可以简化他们的依赖关系。</li>
</ul>
<h1 id="对象去耦"><a href="#对象去耦" class="headerlink" title="对象去耦"></a>对象去耦</h1><ul>
<li>中介者</li>
<li>观察者</li>
</ul>
<h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><blockquote>
<p>中介者模式： 用一个对象来封装一系列对象的交互方式。中介者使得个对象不需要显示的相互引用，从而使得耦合松散，而且可以独立地改变他们之间的交互。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="中介者模式"></p>
<p>简单的说就是单独使用一个对象C来管理A对象和B对象之间的交互或者说将A和B中较为复杂的逻辑抽象出来。减少A和B之间的耦合，便于A和B对象的重用。</p>
<h3 id="何时使用中介者模式"><a href="#何时使用中介者模式" class="headerlink" title="何时使用中介者模式"></a>何时使用中介者模式</h3><ul>
<li>对象之间的交互虽然定义明确但是非常复杂，导致一组对象项目依赖并且难以理解。</li>
<li>因为对象引用了许多其他对象并与其通信，导致对象难以复用。</li>
<li>想要定制一个分布在多个类中的逻辑或行为，又不想生成太多的子类。</li>
</ul>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><blockquote>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="观察者模式"></p>
<p>观察者模式在iOS里面的使用频率比较多，框架也已经帮我们实现了方便使用的方式。首先是NSNotificationCenter，再者还有KVO，所以基本已经可以满足我们的需求。目的就是解除观察者和被观察者之间的关系。</p>
<h1 id="抽象集合"><a href="#抽象集合" class="headerlink" title="抽象集合"></a>抽象集合</h1><ul>
<li>组合</li>
<li>迭代器</li>
</ul>
<h2 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h2><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E6%A0%91%E5%BD%A2%E7%BB%93%E6%9E%84.png" alt="树形结构"></p>
<p>我们可以看到如上图所示的一个树形就够就是组合模式，在这个树形结构当中，线段既包含节点，也包换线段，但是client使用的时候并不关心Stroke包含什么，只是想要统一的处理。所以组合模式可以对外操作保持一致性。</p>
<p>在CocoaTouch中一个非常典型的例子就是UIView。UIView可以嵌套UIView，Client只需要对父View做响应的处理，父View就可以递归的调用子View，像渲染视图的命令，父View接收到只之后就会逐级向下传递。</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><blockquote>
<p>提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示</p>
</blockquote>
<p>苹果公司用自己的命名规则“枚举器/枚举”改写了迭代器模式，用于相关基础类的方法。基础框架中的NSEnumerator类实现了迭代器模式。NSArray，NSSet，NSDictionary这样的集合类，定义了返回与集合的类型想响应的NSEnumerator子类实例的方法。用我这种比较通俗的说法就是，提供了一种遍历集合类的方法。也就是迭代器模式。</p>
<blockquote>
<p>基本上有两种迭代器：外部迭代器和内部迭代器。外部迭代器让client直接操作迭代过程，所以client需要知道外部迭代器才能使用。另一种情况是，集合对象（被迭代的目标对象）在其内部维护并操作了一个外部迭代器。提供内部迭代器的典型的集合对象为client定义一个接口，或者从底层集合一次访问一个元素，或者向每个元素发送消息。比如NSArray 的  <em>- （void）makeObjectsPerformSelector:(SEL)aSelector</em> 就是内部迭代器。就是不需要知道迭代器，在内部都遍历并实现操作。</p>
</blockquote>
<h3 id="何时使用-5"><a href="#何时使用-5" class="headerlink" title="何时使用"></a>何时使用</h3><ul>
<li>需要访问组合对象的内容，而又不暴露内部表示。</li>
<li>需要通过多种方式暴露组合对象。</li>
<li>需要提供一个统一的接口，来遍历各种类型的组合对象。</li>
</ul>
<h1 id="行为扩展"><a href="#行为扩展" class="headerlink" title="行为扩展"></a>行为扩展</h1><ul>
<li>访问者模式</li>
<li>装饰</li>
<li>责任链</li>
</ul>
<h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><blockquote>
<p>表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素类的前提下定义作用于这些元素的新操作。</p>
</blockquote>
<p><img src="http://o835bn5qj.bkt.clouddn.com/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png" alt="访问者模式"></p>
<p>解释一下访问者模式，就是将自己不熟悉的业务承包出去。比如说我们的家是一个类，对于里面的下水道我们就有各种使用的方法，但是关于修理下水道我们要承包出去，找专业的人来对他进行操作，而这个维修的操做不能影响我们现在的使用。所以这就是访问者模式，承包商就是访问者。这样比较容易理解。<br>从类图上可以看出来，Element调用 <em>acceptVister:</em> 方法将自身传递给vister，vister接收之后就可以对其进行操作。从而可以获得行为的扩展。</p>
<h3 id="何时使用访问者模式"><a href="#何时使用访问者模式" class="headerlink" title="何时使用访问者模式"></a>何时使用访问者模式</h3><ul>
<li>一个复杂的对象结构包含很多其他的对象，它们有不同的接口（比如组合体），但是相对这些对象实施一些依赖其具体类型的操作。</li>
<li>需要对一个组合结构中的对象进行很多不相关的操作，但是不想让这些操作“污染”这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它。</li>
<li>定义复杂结构的类很少作修改，但是经常需要向其添加新的操作。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[iOS知识点汇总(持续更新...)]]></title>
      <url>http://lixuzong.com/2016/08/09/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      <content type="html"><![CDATA[<p>记录开发过程中遇到的小知识点。<br><img src="http://odbghk3il.bkt.clouddn.com/draw_dog.jpeg" alt="狗"><br><a id="more"></a></p>
<h2 id="JDNetLog-s-…-引发的问题"><a href="#JDNetLog-s-…-引发的问题" class="headerlink" title="JDNetLog(s,…)引发的问题"></a>JDNetLog(s,…)引发的问题</h2><p>在做自己的项目的时候，一遍都会重新定义NSLog宏，方便在发布的时候将打印的log去除。这里就不多少了，首先贴上代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define JDNetLog(s, ...) [[JDiPadNetworkingLog sharedNetworkingLog] file:__FILE__ function: (char *)__FUNCTION__ \</span></span><br><span class="line">lineNumber:__LINE__ format:(s),<span class="meta">##__VA_ARGS__]</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)file:(<span class="keyword">char</span>*)sourceFile function:(<span class="keyword">char</span>*)functionName lineNumber:(<span class="keyword">int</span>)lineNumber format:(<span class="built_in">NSString</span>*)format, ...</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">NSString</span> *print, *file, *function;</span><br><span class="line"><span class="comment">//    NSMutableString *mStr = [NSMutableString string];</span></span><br><span class="line">    va_start(ap,format);</span><br><span class="line">    file = [[<span class="built_in">NSString</span> alloc] initWithBytes:sourceFile length:strlen(sourceFile) encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    function = [<span class="built_in">NSString</span> stringWithCString: functionName encoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"><span class="comment">//    if (format) &#123;</span></span><br><span class="line"><span class="comment">//        do &#123;</span></span><br><span class="line"><span class="comment">//            [mStr appendString:[NSString stringWithFormat:@"%@",format]];</span></span><br><span class="line"><span class="comment">//            format = va_arg(ap, id);</span></span><br><span class="line"><span class="comment">//        &#125; while (format);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">//问题的根源就是没有理解这个函数！</span></span><br><span class="line">    print = [[<span class="built_in">NSString</span> alloc] initWithFormat:format arguments:ap];</span><br><span class="line"><span class="comment">//    print = [mStr copy];</span></span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_dateformatter) &#123;</span><br><span class="line"></span><br><span class="line">        _dateformatter=[[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">        [_dateformatter setDateStyle:<span class="built_in">NSDateFormatterShortStyle</span>];</span><br><span class="line">        [_dateformatter setDateFormat:<span class="string">@"yyyy-MM-dd HH:mm:ss.SSS"</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *date = [_dateformatter stringFromDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">    [<span class="keyword">self</span> addLog:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"\n[%@]\n%@:%d\n%@;\n%@\n"</span>,date ,[file lastPathComponent], lineNumber, function, print]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先说一下 <em>…</em> 这个函数，在iOS里面，这个表示的是可变的参数类型，也就是不定参数个数。处理的方法是用C语言的语法<em>va_list, va_start, va_end,va_arg(ap,type)</em> 首先声明一个 <em>va_list</em> ,使用 <em>va_start</em> 方法初始化这个 <em>va_list</em> ,也就是传入第一个参数的指针进行初始化，<em>va_arg</em>就是来将指针指向下一个参数，这样就可以根据链条一直找到最后一个参数，最后就 <em>va_end</em> 就结束了。这里主要是对 <em>print = [[NSString alloc] initWithFormat:format arguments:ap];</em> 函数理解错误了，看到这个函数传的是首指针的地址和 <em>va_list</em> ，之前自以为是以为是将之后传的所有参数都与前面拼接之后生成一个字符串，其实并不是这样，这个方法与 <em>[NSString stringWithFormat:@”%@”,format]</em> 类似，只是将前面的format与arguments分开了而已，也是要遵循 <em>@”%@%@”,argument1, argument2</em> 这样的格式，所以函数里传入的 <em>va_list</em> 只是符合这个格式 <em>arguments</em> ，并不是我们传递进去的 <em>va_list</em>。所以在使用 <em>JDNetLog(s,…)</em> 时要注意传入的格式。</p>
<h2 id="关于面向接口编程"><a href="#关于面向接口编程" class="headerlink" title="关于面向接口编程"></a>关于面向接口编程</h2><p>今天完成了任务之后，突然想到了在书上看到的面向接口编程，而不是面向对象编程，也是困惑了一段时间（尼玛，老子在学校学的都是面向对象，你现在有不用了？）。今天大概了解了一下，其实并不是要抛弃面向对象的思想，而是减少对象依赖。简单的说就是不要在其他类中直接使用对象的属性，而是包装一层在接口里面，直接使用接口。针对iOS来说就是尽量的将对象的属性封装成接口之后，对外暴露接口，而不是对外暴露属性。既然是面向接口编程，那么最彻底的就是使用@protocol了，因为@protocol就是将接口抽象出来。这里主要参考了<a href="http://www.olinone.com/?p=429" target="_blank" rel="external">这篇文章</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native开源项目笔记(1):redux管理数据]]></title>
      <url>http://lixuzong.com/2016/07/15/react-native%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>首先放上开源项目的地址：<a href="https://github.com/ljunb/react-native-iShiWuPai" target="_blank" rel="external">React-Native开源项目iShiWuPai</a><br>这边笔记主要是记录看开源项目iShiWuPai之后的一些知识点。前端的话一般都是使用的MVC框架，这样的话我也是从这三个方面学习，这个项目中的数据的话用的是Redux框架，View的话就是使用ReactNative框架。</p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/shouhui2.jpg" alt="手绘"></p>
<a id="more"></a>
<h2 id="index-ios-js文件"><a href="#index-ios-js文件" class="headerlink" title="index.ios.js文件"></a>index.ios.js文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; AppRegistry &#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"><span class="keyword">import</span> Root <span class="keyword">from</span> <span class="string">'./app/root'</span>;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(<span class="string">'iShiWuPai'</span>, () =&gt; Root);</span><br></pre></td></tr></table></figure>
<p><em>Root</em> 文件是主入口，<em>AppRegister.registerComponent（）</em> 方法是用来注册ReactNative，第一个字符串要和iOS项目中注册的一致，第二个传入的是根类。</p>
<blockquote>
<p>这里的 <em>()=&gt;Root</em> 的写法有点像iOS的Block块，姑且当做是JS里面匿名函数的写法吧。</p>
</blockquote>
<h2 id="root-js文件"><a href="#root-js文件" class="headerlink" title="root.js文件"></a>root.js文件</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="comment">//这个是结构化好的state数据</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/store'</span>;</span><br><span class="line"><span class="comment">//这个是项目的主要逻辑</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./containers/app'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Root</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            &lt;Provider store = &#123;store&#125; &gt;</span><br><span class="line">                 &lt;App /&gt;</span><br><span class="line">            &lt;/Provider&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用到了<em>react-redux</em>文件，<em>redux</em> 主要是用来处理数据，管理state而存在的，将工程中使用的所有state结构化成树结构，这样的话就可以跟踪state的变化（大概就先了解这么多，以后再具体研究）。使用方法大概就是引入 <em>Provider</em> 类，并且将准备好的 <em>store</em>（就是已经结构化好的数据）传入。刚开始学习的时候不太懂怎么使用其他文件中的类的，这里看到 <em>export</em> 关键字就联系到了iOS中的 <em>public</em> 关键字，这样的话只要导入这个文件之后就可以直接使用 <em>export</em> 修饰的类了。</p>
<h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>这里参考了文章：<a href="https://rhadow.github.io/2015/07/30/beginner-redux/" target="_blank" rel="external">redux入门</a></p>
<h3 id="store-js文件"><a href="#store-js文件" class="headerlink" title="store.js文件"></a>store.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">'redux'</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">'redux-thunk'</span>;</span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'../reducers/rootRudcer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> createStoreWithMiddleware = applyMiddleware(thunk)(createStore);</span><br><span class="line"><span class="keyword">let</span> store = createStoreWithMiddleware(rootReducer);</span><br><span class="line"><span class="comment">// let state = store.getState();</span></span><br><span class="line"><span class="comment">// alert(state.Search.searchText)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure>
<p>这里 <em>redux</em> 和 <em>redux-thunk</em> 的使用方法就是像代码里写的一样。<em>reducer</em> 是用来管理 <em>state</em> 和 <em>action</em> 类，这里每个页面的数据就是使用一个 <em>reducer</em> ，<em>rootReducer</em> 是各个 <em>reducer</em> 的集合。 <em>action</em> 是用来更新 <em>state</em> 的，因为将所有的state都集中在一起管理，那么用 <em>action</em> 来更新 <em>state</em> 就不会产生混乱了。就是可以理解成 <em>reducer</em> 提供了一个容器，在这个容器里面用 <em>action</em> 来更新 <em>state</em> 。<em>let store = createStoreWithMiddleware(rootReducer);</em> 这句换就是将 <em>reducer</em> 和 <em>store</em> 发生关联，这样当 <em>store</em> 里面的数据发生改变的时候就会触发 <em>Action</em> 事件。</p>
<blockquote>
<p>middleware是用来实现 <em>dispatch</em> 方法的异步或者同步执行等不同的状态，这里使用的是异步的 <em>dispatch</em> 方法。</p>
</blockquote>
<p><img src="http://user-image.logdown.io/user/8925/blog/8821/post/332288/tPbal8BSc6vs06ti0FVQ_Redux-multi-reducer.jpg" alt="更新state流程"></p>
<p><img src="http://user-image.logdown.io/user/8925/blog/8821/post/332288/NqajldzQTpWbXR3YjEyN_Redux-middleware.jpg" alt="middleware作用"></p>
<h3 id="strollingReucer-js"><a href="#strollingReucer-js" class="headerlink" title="strollingReucer.js"></a>strollingReucer.js</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义所有types的地方</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'../actions/actionTypes'</span>;</span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">    bannerList: [],</span><br><span class="line">    feedList: [],</span><br><span class="line">    isLoading: <span class="literal">true</span>,</span><br><span class="line">    isLoadMore: <span class="literal">false</span>,</span><br><span class="line">    isRefreshing: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> strollingReducer = (state = initialState, action) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> types.FETCH_BANNER_LIST:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> types.RECEIVE_BANNER_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                bannerList: action.bannerList,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">case</span> types.FETCH_FEED_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                isLoadMore: action.isLoadMore,</span><br><span class="line">                isRefreshing: action.isRefreshing,</span><br><span class="line">                isLoading: action.isLoading,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">case</span> types.RECEIVE_FEED_LIST:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                feedList: state.isLoadMore ? state.feedList.concat(action.feedList) : action.feedList,</span><br><span class="line">                isRefreshing: <span class="literal">false</span>,</span><br><span class="line">                isLoading: <span class="literal">false</span>,</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> strollingReducer;</span><br></pre></td></tr></table></figure>
<p><em>reducer</em> 的任务就是将传入的旧 <em>state</em> 和 <em>action</em> 更新并返回新的 <em>state</em> 。示例代码中的 <em>strollingReducer</em> 就是 <em>rootReducer</em> 中的一个。</p>
<h3 id="strollingActions-js文件"><a href="#strollingActions-js文件" class="headerlink" title="strollingActions.js文件"></a>strollingActions.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> types <span class="keyword">from</span> <span class="string">'./actionTypes'</span>;</span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'../common/utils'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> fetchBanners = ()=&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> URL = <span class="string">'http://food.boohee.com/fb/v1/home/banners'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dispatch =&gt; &#123;</span><br><span class="line">        <span class="comment">// 请求轮播数据</span></span><br><span class="line">        dispatch(fetchBannerList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Util.get(URL, (response) =&gt; &#123;</span><br><span class="line">            dispatch(receiveBannerList(response.banners))</span><br><span class="line">        &#125;, (error) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'Fetch banner list error: '</span> + error);</span><br><span class="line">            dispatch(receiveBannerList([]));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fetchBannerList = ()=&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: types.FETCH_BANNER_LIST,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> receiveBannerList = (bannerList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: types.RECEIVE_BANNER_LIST,</span><br><span class="line">        bannerList: bannerList,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是对应的的 <em>strolling</em> 类的 <em>action</em> 文件,这里需要更新 <em>state</em> 的情况就是加载网络数据之后更新。之前一直在想 <em>strollingAction</em>  是如何将自身传递给 <em>strollingReducer</em> 的，这里是自己理解的 <em>dispatch</em> 的作用。既然最后要将 <em>reducer</em> 合并成一个，这样的话 <em>dispatch</em> 直接操作的是 <em>state</em> 树结构，所有的 <em>action</em> 也都会返回一个固定的结构:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> receiveBannerList = (bannerList) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        type: types.RECEIVE_BANNER_LIST,</span><br><span class="line">        bannerList: bannerList,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里返回的就是一个 <em>action</em> ，格式基本上就是这样。</p>
<h3 id="Strolling-js文件"><a href="#Strolling-js文件" class="headerlink" title="Strolling.js文件"></a>Strolling.js文件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">        InteractionManager.runAfterInteractions(() =&gt; &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;dispatch&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">            dispatch(fetchBanners());</span><br><span class="line">            dispatch(fetchFeeds(page, canLoadMore, isRefreshing, isLoading));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> &#123;Strolling&#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> bannerList = Strolling.bannerList;</span><br><span class="line">        <span class="keyword">let</span> feedList = Strolling.feedList;</span><br><span class="line">        <span class="keyword">let</span> sourceData = &#123;<span class="string">'banner'</span>: [bannerList], <span class="string">'feed'</span>: feedList&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> sectionIDs = [<span class="string">'banner'</span>, <span class="string">'feed'</span>];</span><br><span class="line">        <span class="keyword">let</span> rowIDs = [[<span class="number">0</span>]];</span><br><span class="line">				...</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>在 <em>Strolling</em> 中使用数据的时候有两个个地方没有看明白， <em>const {dispatch} = this.props</em> 和 <em>const {Strolling} = this.props</em> 。通过查 <em>redux</em> 文档，原来这个地方能从props里直接取到 <em>dispatch</em> 和 <em>Strolling</em> 是因为框架调用了React Redux connect()注入props。这样的话就做到了数据的传输使用。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[以iOS开发的角度了解HTTP协议]]></title>
      <url>http://lixuzong.com/2016/06/23/%E4%BB%8EiOS%E5%BC%80%E5%8F%91%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3HTTP/</url>
      <content type="html"><![CDATA[<p>目前做iOS开发以来，使用的都是HTTP协议，所幸现在接触到的东西还是之前的知识储备所能够应付的，正好趁着还没有入职的这段时间补充点这方面的知识，当然还是从我比较熟悉的iOS的角度来进行学习。最近看的书是《图解HTTP》，也算是看了该书的一个总结吧。</p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/HTTP_book" alt="shouhuiImage"></p>
<a id="more"></a>
<h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h3><p>首先TCP/IP协议族不仅包括了TCP协议和IP协议，而是很多协议的总称。TCP/IP协议按照层次分为4层，分别是：应用层、传输层、网络层和数据链路层。HTTP协议在应用层，之后是传输层的TCP协议，然后是网络层的IP协议，数据链路层是与硬件相关的协议。HTTP协议规定一端是客户端，一端是服务器，这样的话数据流从客户端从上至下传输，每经过一层就加上报文头，到了服务器端之后数据流就会从下至上逐成解析。</p>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3><p>为了准确无误的将数据送到目标处，并且能够确认数据最终是否送达到对方。为了实现这个目标，TCP采用三次握手的方式。</p>
<p>结合实际中的例子比较容易理解三次握手是怎么实现的。比如在古代，A托商队给B一个东西，并且双方都要确认这条线路的安全性，那么A在这个东西里面放了一个标志SYN，B收到之后在东西里面放置了ACK表明B已经知道了，商队回来的时候将东西交还给A，A会看到自己放置的SYN和B放置的ACK，这样的话A就可以确认这条道路的安全性，但是这个时候B并不知道A收到了数据，所以这个时候A还需要在东西里放置ACK给B表明A收到了东西。简单的说就是每个端发送出东西的时候都要获得回应才能确认东西到达，所以就是三次。</p>
<h3 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h3><p>IP协议的作用就是把各种数据包传给对方。为了能确保准确送达，所以需要IP地址和MAC地址，IP地址指明了节点被分配的地址，MAC地址指的是网卡所属的固定地址，IP地址可变换，但是MAC地址是不会改变的。所以IP间的通信就需要MAC地址，这里就需要知道IP地址和MAC地址的对应关系，所以又出现了另一种协议ARP（Address Resolution Protocol），能通过IP地址查询到MAC地址。</p>
<h3 id="HTTP数据流程图"><a href="#HTTP数据流程图" class="headerlink" title="HTTP数据流程图"></a>HTTP数据流程图</h3><p><img src="http://o835bn5qj.bkt.clouddn.com/IMG_3842.JPG" alt="HTTP"></p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><p>首先先接受几个和HTTP相关的短语。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。</p>
<blockquote>
<p>在开发过程中经常需要翻墙，也就是使用在国外的代理，这样的话就可以正常访问国外的网站了。</p>
</blockquote>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>网关是转发其他服务器通信数据的服务器，接收从客户端接收到的请求之后会对请求进行处理，有时候客户端本身并不知道自己对接的是一个网关。</p>
<h3 id="HTTP首部"><a href="#HTTP首部" class="headerlink" title="HTTP首部"></a>HTTP首部</h3><p>HTTP协议首先是客户端和服务器之间的协议，在没有扩展协议的情况下只能从客户端发起请求然后服务端返回响应。</p>
<table>
<thead>
<tr>
<th>请求报文首部</th>
<th>响应报文首部</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求行</td>
<td>响应首部字段</td>
</tr>
<tr>
<td>请求首部字段</td>
<td>通用首部字段</td>
</tr>
<tr>
<td>通用首部字段</td>
<td>实体首部字段</td>
</tr>
<tr>
<td>实体首部字段</td>
<td>其他</td>
</tr>
<tr>
<td>其他</td>
</tr>
</tbody>
</table>
<p>这是一个简单的示意图，分别展示了请求报文首部和响应报文的首部。这里可以看到通用首部字段和实体首部字段这两个部分是相同的，只是在请求首部字段和响应首部字段会有区别。</p>
<blockquote>
<p>GET / HTTP/1.1<br>Host: hackr.jp<br>User-Agent: Mozilla/5.0<br>Accept: text/html, application/xml;q=0.9<br>Accept-language: ja, en-us</p>
</blockquote>
<p>这里列举了几个我们经常看到的请求报文首部参数，这里写明了请求是GET方法的请求，使用的是HTTP/1.1协议，请求的地址是<em>hackr.jp</em>，客户端接收的数据是HTML数据…各种首部非常多，在用到的时候可以查阅相关的资料。</p>
<h3 id="iOS中会用到的首部"><a href="#iOS中会用到的首部" class="headerlink" title="iOS中会用到的首部"></a>iOS中会用到的首部</h3><p>HTTP/1.1协议中有很多的首部，但是大部分是针对浏览器来使用的，就目前的知识储备来看，在iOS开发当中有用到的首部有请求首部If-Match和响应首部的Etag配合使用来做网络缓存；还有HTTP的扩展协议Cookie来记录用户的登陆状态。</p>
<h4 id="If-Match-amp-Etag"><a href="#If-Match-amp-Etag" class="headerlink" title="If-Match &amp; Etag"></a>If-Match &amp; Etag</h4><p>之前看过一篇文章讲的是iOS缓存，其中有一个讲到的就是利用HTTP协议自带的网络缓存来实现。</p>
<blockquote>
<p>If-Match: “123456”</p>
</blockquote>
<p>只有当服务器资源的Etag的值为 <em>“123456”</em> 时，才会对客户端的请求作出响应，因为资源的更新那么Etag值就会发生更新，所以可以识别出资源是否已经更新或者已经过期。</p>
<h4 id="If-Modifield-Since"><a href="#If-Modifield-Since" class="headerlink" title="If-Modifield-Since"></a>If-Modifield-Since</h4><p>这个参数是请求报文首部中的参数，可以指定资源的有效时间，从字面上就可以看出如果从给出的时间上没有更新的话，服务器就会返回 <em>304 Not Modifield</em> ,如果有更新就会返回资源并且响应首部上也会加上 <em>Last-Modifield: last time</em></p>
<h4 id="Cookie-amp-amp-Set-Cookie"><a href="#Cookie-amp-amp-Set-Cookie" class="headerlink" title="Cookie &amp;&amp; Set-Cookie"></a>Cookie &amp;&amp; Set-Cookie</h4><p>Cookie是请求报文首部字段，Set-Cookie是响应报文首部字段。首先是服务器返回Set-Cookie字段将Cookie值返回给客户端，客户端每次请求的时候将该值赋值给Cookie字段，用这种形式来确定用户登录。我们在开发iOS客户端的时候往往需要使用Token来实现用户登录，我们可以利用HTTP的这个属性来进行认证。</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>由于iOS要求全面要支持https协议，所以还是有必要了解下什么是HTTPS协议。</p>
<blockquote>
<p>HTTP + 加密 + 认证 + 完整性保护 = HTTPS</p>
</blockquote>
<p>HTTPS并非是一个新的协议，只是HTTP通信接口部分使用SSL和TLS协议代替而已。HTTP是直接和TCP通信，HTTPS是先和SSL通信，SSL和TCP通信，所以说HTTPS就是套了一层SSL协议外壳的HTTP协议。</p>
<h3 id="证书"><a href="#证书" class="headerlink" title="证书"></a>证书</h3><p>iOS开发中对各种各样的证书并不陌生，有开发者证书、发布证书、推送证书等等…  </p>
<p>要了解证书首先要知道非对称加密算法。非对称加密算法就是A经过一个固定的运算可以得到B，并且通过B可以得到A，利用这个数学公式，我们就可以用A来对数据加密，用B来对数据解密。这是基于这样的一个数学公式而产生的算法。这样的话就可以公开A或者B中的一个，被公开的那个就是公钥，保留的要私钥，这样的话谁都可以用公钥来加密，但是能解密的只有私钥。  </p>
<p>证书就是用来保存公钥的，且证明公钥的有效性。因为公钥是要发布出去的，但是公钥也需要证明其自身是有效的，这样的话就产生了证书。证书原本的意思就是权威机构发布的能有效证明的文件，那么这里的证书也是同样的道理。是权威机构发布的对公钥有效性的证明文件。这里的权威机构是被大家所认可的几家机构，如果是想要提交公钥来开具证书是需要收费的，所以Apple公司为了安全性还是挺舍得花钱的。</p>
<h3 id="HTTPS的认证过程"><a href="#HTTPS的认证过程" class="headerlink" title="HTTPS的认证过程"></a>HTTPS的认证过程</h3><p><img src="http://o835bn5qj.bkt.clouddn.com/https.JPG" alt="https"></p>
<blockquote>
<p>最后在iOS开发中如果遇到http问题的时候再进行补充。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[React Native从最基础学起]]></title>
      <url>http://lixuzong.com/2016/06/13/React%20Native%E4%BB%8E%E6%9C%80%E5%9F%BA%E7%A1%80%E5%AD%A6%E8%B5%B7%20/</url>
      <content type="html"><![CDATA[<p>这篇文章主要讲的的内容是没有JavaScript基础的情况下开发React Native应用需要知道的基础知识。也是我在学习React Native框架的一个学习曲线。以方便记录下来方便查阅，一方面希望可以帮助到和我一样的菜鸟减少学习时间。</p>
<p><img src="http://o835bn5qj.bkt.clouddn.com/shouhui1.jpg" alt="shouhuiImage"></p>
<a id="more"></a>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="var和let的区别"><a href="#var和let的区别" class="headerlink" title="var和let的区别"></a>var和let的区别</h3><p>var声明的变量是无视作用域的，而let是在作用域里有效的。</p>
<blockquote>
<p>这里需要和swift中的var和let区分，var是是可以改变的值，而let是不可以改变的值，与作用域无关。</p>
</blockquote>
<h3 id="匿名函数的写法"><a href="#匿名函数的写法" class="headerlink" title="匿名函数的写法"></a>匿名函数的写法</h3><p>与swift语法一样，函数也是对象类型，也可作为函数的返回值来只用，但是匿名函数的写法有所不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (valueA, valueB) =&gt; &#123;</span><br><span class="line">		<span class="keyword">return</span> valueA +valueB;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="built_in">console</span>.log(addFunc()(<span class="number">1.2</span>)); <span class="comment">//输出3</span></span><br></pre></td></tr></table></figure>
<h3 id="与-的区别"><a href="#与-的区别" class="headerlink" title="==与===的区别"></a>==与===的区别</h3><p>与其他语法不同点是==比较左右的值，只要值相等，结果就是true。而===不仅比较值，也比较类型，只有两者相等才返回true。</p>
<blockquote>
<p>‘!=’是值不相等，‘！==’是值和类型都不相等</p>
</blockquote>
<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul>
<li>this 关键字表示类对象本身，如果在类内使用函数之类通过this来调用</li>
<li>类的构造函数<em>constructor(valueA,valueB)</em>创建类的使用调用</li>
<li>可以通过<em>static</em>和<em>Class.obj</em>两种方式创建静态变量</li>
<li>类中定义的函数可以省略关键字<em>function</em></li>
<li>通过<em>this.obj</em>来创建字段，可以在类的构造函数里面创建也可以在函数外创建，如果是未创建的字段其值为<em>undefined</em></li>
<li>字段的只读和只写属性通过<em>get</em>和<em>set</em>关键字来声明，这里可以跟objective-C的方法类比。</li>
<li>类的继承使用extend关键字，在子类里调用super就可以调用父类的函数。</li>
<li>对象使用new来生成，还有一种情况是直接生成匿名类对象，用键值对的形式创建对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">   	name: <span class="string">'obj'</span>,</span><br><span class="line">   	value: <span class="string">'lalala'</span>,</span><br><span class="line">  	 	sayHello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">       	<span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + name);</span><br><span class="line">   	&#125;,</span><br><span class="line">   	sayHi: (name) =&gt; &#123;</span><br><span class="line">       	<span class="built_in">console</span>.log(<span class="string">'Hi! '</span> + name);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="文件的导入和导出"><a href="#文件的导入和导出" class="headerlink" title="文件的导入和导出"></a>文件的导入和导出</h2><p>首先说一下相对路径，使用 . 就是在当前路径查找，如果是..就是从上层路径查找，没有 . 或者 / 开头的就是从项目根目录开始查找。</p>
<h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>导出的时候需要使用<em>export</em>关键字,可以到出变量、类、函数，可以定义默认导出内容，需要加上<em>export default</em>关键字</p>
<h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>导入文件使用关键字<em>import</em>,<em>from</em>格式是 <em>import [something] from ‘相对路径’</em> 。如果是没有使用默认导出的情况下可以根据需要接收需要的属性，一般是全部接收，如果有默认导出的话可以直接接收默认导出，并且默认导出是唯一的！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">'lala'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> age = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="comment">// 如果只需要 value 和 name</span></span><br><span class="line"><span class="keyword">import</span> &#123;value, name&#125; <span class="keyword">from</span> <span class="string">'./data.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想将所有由 export 导出的都引入</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> data <span class="keyword">from</span> <span class="string">'./data.js'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(data.value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认导入可以任意取名</span></span><br><span class="line"><span class="keyword">import</span> anyName <span class="keyword">from</span> <span class="string">'./data.js'</span></span><br><span class="line"><span class="built_in">console</span>.log(anyName);	</span><br></pre></td></tr></table></figure>    
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p><img src="http://o835bn5qj.bkt.clouddn.com/reactnativeLifeCycle.png" alt="liftCycle"><br>在整个ReactJS的生命周期中，主要经历4个阶段：创建阶段、实例化阶段、更新阶段和销毁阶段。</p>
<h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p>   这个阶段会调用<em>getDefaultProps</em>方法，并返回一个对象缓存下来，然后与父组件制定的props对象合并，最后赋值给this.props作为默认属性。</p>
<blockquote>
<p><em>props</em>是一个对象，是组件用来接收外面参数的，不支持在内部修改自己的<em>props</em>属性,只能通过父组件来赋值。<em>getDefaultProps</em>方法是用来设置默认值得。</p>
</blockquote>
<h3 id="实例化阶段"><a href="#实例化阶段" class="headerlink" title="实例化阶段"></a>实例化阶段</h3><p>该阶段是在实例化组件类的时候，也就是该组件类被调用的时候。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">React.render (</span><br><span class="line">	&lt;List name = "ReactJS"&gt;&lt;/List&gt;</span><br><span class="line">	<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>我们初始化了一个<em>List</em>组件，这个时候看一下依次调用的生命周期方法。</p>
<ol>
<li><em>getInitialState</em> 初始化组件的state值，其值会被赋值给this.state属性。</li>
<li><em>componentWillMount</em> 组件即将被加载到视图上的时候调用，根据业务对state进行相应的操作</li>
<li><em>render</em> 根据state的值，生成页面需要的虚拟DOM结构，并返回该结构。</li>
<li><em>componentDidMount</em> 对根据虚拟DOM结构而生成的真是DOM进行相应的处理。为了保证不出现UI上的错误，在这个函数里面发起请求接收网络数据。这个时候改变this.state属性就会出发ReactJS内部的监听事件，再次调用<em>getInitialState</em>函数，这样的话再次刷新界面。</li>
</ol>
<h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><p>这主要发生在用户操作之后或者父组件有更新的时候，此时会根据用户的操作进行相应的调整。</p>
<ol>
<li><em>componentWillReceiveProps(object nextProps)</em> 当组件接收到新的<em>props</em>时，会触发该函数。在该函数中通常可以调用<em>this.state</em>完成对<em>state</em>的修改。</li>
<li><em>shouldComponentUpdate(nextProps nextState)</em> 该方法会拦截新的<em>props</em>和<em>state</em>，然后根据事先判定好的判断逻辑，做出最后要不要更新组件的决定。</li>
<li><em>componentWillUpdate(object nextProps, object nextState)</em> 当方法2返回的是true的时候这里就做一些更新前的操作。</li>
<li><em>render</em> 根据一系列的diff算法，生成需要更新的虚拟DOM数据。最好在这里进行数据和模板的整合，不进行state的操作。</li>
<li><em>componentDidUpdate</em> 该方法在组件更新已经同步到DOM中后出发，我们通常在该方法中做一些DOM操作。</li>
</ol>
<h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p><em>componentWillUnmount</em> 当组件从DOM中移除的时候调用这个方法，通常会在这个方法中做一些取消事件绑定，销毁定时器等工作。</p>
<blockquote>
<p>就相当于iOS中的dealloc函数。   </p>
</blockquote>
<h2 id="参考文章链接"><a href="#参考文章链接" class="headerlink" title="参考文章链接"></a>参考文章链接</h2><p><a href="http://blog.csdn.net/yuanguozhengjust/article/details/50470171" target="_blank" rel="external">http://blog.csdn.net/yuanguozhengjust/article/details/50470171</a><br><a href="https://lzxhahaha.gitbooks.io/react-native-getting-start/content/index.html" target="_blank" rel="external">https://lzxhahaha.gitbooks.io/react-native-getting-start/content/index.html</a></p>
]]></content>
    </entry>
    
  
  
</search>
